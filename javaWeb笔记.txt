

---------------myEclipse-----------------【START】
快捷键：
	代码补全 		Content Assist 		alt + w（改）
	快速导\删包		Organize Imports 	ctrl + shift + o
	移动当前行		Move Lines Up/Down 	ctrl + shift + 上下键头（改） 
	复制当前行		Copy Lines			ctrl + shift + d（改）
	删除当前行  	Delete Line 		ctrl + shift + k（改）
	快速修复		Quick Fix			ctrl + 1
	单行注释		Toggle Comment 		ctrl + /
	多行注释		Add Block Comment	ctrl + shift + /
	取消多行注释						ctrl + shift + \
	代码格式化		Format				ctrl + shift + f
	变量改名							ctrl + 2,R
	接收返回值							ctrl + 2,L
	查看继承树		Quick Hierarchy		ctrl + T
	查看源码							ctrl + 鼠标悬浮


WEB-INF > lib中的所有jar包，右键 > build path > add to ..

配置是跟着工作空间走的：Window -> Preferences ->
	General -> workspace -> utf-8
	General -> editors -> associations -> jsp -> myEclipse jsp editor
	搜索jsp -> utf-8

添加jdk：
	java -> Installed JREs -> 添加

取出MyEclipse自带tomcat：
	General -> Startup and Shutdown -> MyEclipse Derby

把项目导入myEclipse：
	import - general -existing projects into workspace

JRE System Library是JRE中的类库，是很多编译后的.class文件（不是源文件.java）。在该位置可以找到常用的String类、Random类、Math类等。

生成文档注释	export - javaDoc
生成jar包		export - jar


-----------------实体类？-----------------
实体类是对应数据库表的，属于javaBean的一种。


为什么有时候不建实体类？
	1. 懒
	2. 实体类中规定了变量类型，如果跟数据库中的变量类型不一致，需要转换的时候，容易出问题。


	

-----------------前后交互-----------------
前 -> 后传输方式：
	1 form表单
		name很重要
		其他参数可以放到<input type="hidden">中传
		后端返回的时候，直接返回新的url地址：
			response.sendRedirect("新地址?username=emily");

	2 ajax
		后端返回的时候，直接返回参数：
			response.setContentType("application/json;charset=UTF-8");
			PrintWriter out = response.getWriter();
			out.print(result);
		前端接到参数，再进行处理

无论使用get还是post，都是只在传输过程中有差别（一个在url，一个在请求体）。
对于后端的servlet，它接收数据时没有区别，都是用：
	request.setCharacterEncoding("utf-8");
	String username = request.getParameter("username");




-----------------web资源 tomcat-----------------
web资源：
	静态资源：html
	动态资源：jsp servlet（浏览器请求动态资源时，服务器需要先把动态资源转换为静态资源html，再返回给浏览器）

tomcat是"服务器"+"jsp/servlet容器"
tomcat的默认端口是8080，如果想要修改，去server.xml中修改
tomcat项目放在webapps中，每个项目必须有：
	WEB-INF
		--web.xml
		--classes/
		--lib/



-----------------servlet-----------------
servlet是javaWeb的三大组件之一，它属于动态资源。服务器会把接收到的请求交给Servlet来处理

每个servlet都是唯一的，它们的功能都不同。

servlet类由我们自己写，但是对象由服务器来创建，并且由服务器来调用相应的方法。servlet对象默认是在第一次接到请求后创建，而不是服务器开启后立刻就创建

servlet特性：
	单例，一个类只有一个对象
	线程不安全，速度快

Servlet接口 - GenericServlet类 - HttpServlet类
实现servlet最常用的方式：继承javax.servlet.http.HttpServlet类



-----------------如何让浏览器访问sevlet-----------------
在web.xml中配置：
	<servlet>
		<servlet-name>【servlet的名字，随便起】</servlet-name>
		<servlet-class>【servlet类的qualified name】</servlet-class>
	</servlet>

	<servlet-mapping>
		<servlet-name>【servlet的名字，随便起】</servlet-name>
		<url-pattern>【在浏览器中输入的路径，随便起】</url-pattern>
	</servlet-mapping>




-----------------Servlet接口-----------------	
Servlet接口中有五个函数待实现：
	init：【生命周期方法】在servlet对象创建之后立刻执行，只执行一次
	service：【生命周期方法】每次处理请求，都是调用这个方法，会被调用多次
	destroy：【生命周期方法】在servlet对象被销毁之前调用（留遗言），只执行一次
	getServletInfo
	getServletConfig


GenericServlet类实现Servlet接口



-----------------HttpServlet类-----------------
HttpServlet extends GenericServlet{

	void service(ServletRequest,ServletResponse) --> 生命周期方法
		* 强制转换两个参数为http协议相关的类型
		* 调用本类的service(HttpServletRequest,HttpServletResponse)

	void service(HttpServletRequest,HttpServletResponse) --> 参数已经是Http协议相关的，使用起来更方便
		* 它会通过request得到请求方式（GET或POST）
		* 根据请求方式再调用doGet()或doPost()

	void doGet() 
		* 返回405

	void doPost()
		* 返回405

}  

我们的servlet继承HttpServlet类，只需要重写doGet()和doPost()。
【如果你没有覆盖doGet或doPost，并且它们被调用了，那么会出现405错误】



-----------------servlet小细节-----------------
servlet是线程不安全的：
	所以，如果创建field，field必须是只读的

404页面怎么来的？jsp是谁处理的？
	所有项目中的web.xml，都有一个"父类"：tomcat目录下的conf/web.xml（记为[1]）

		<servlet>
		    <servlet-name>default</servlet-name>
		    <servlet-class>org.apache.catalina.servlets.DefaultServlet</servlet-class>
		</servlet>

		<servlet>
			<servlet-name>jsp</servlet-name>
			<servlet-class>org.apache.jasper.servlet.JspServlet</servlet-class>
		</servlet>


	    <!-- 能匹配所有，所以优先级最低。显示404 -->
	    <servlet-mapping>
	        <servlet-name>default</servlet-name>
	        <url-pattern>/</url-pattern>		
	    </servlet-mapping>

	    <!-- 匹配所有jsp，用来将动态资源jsp转换成浏览器认识的静态资源html -->
	    <servlet-mapping>
	        <servlet-name>jsp</servlet-name>
	        <url-pattern>*.jsp</url-pattern>	
	        <url-pattern>*.jspx</url-pattern>
	    </servlet-mapping>




-----------------自定义错误页面-----------------
web.xml：

	<error-page>
		<error-code>404</error-code>
		<location>/error404.jsp</location>
	</error-page>

	<error-page>
		<error-code>500</error-code>
		<location>/error500.jsp</location>
	</error-page>

可以用Design界面快速生成




-----------------四个域对象-----------------
javaWeb有四个域对象：(范围从大到小)
	ServletContext：同生共死，统计访问量
	HttpSession：会话，维持登录状态
	ServletRequest：请求转发
	PageContext：一个jsp页面中
（前三个域对象servlet jsp都能用，最后一个只在jsp中有效。所以servlet只有三大域对象）


域对象用来传递数据。方法：
	void setAttribute(String name,Object value)
	Object getAttribute(String name)
	void removeAttribute(String name)
	Enumeration getAttributeNames()




-----------------域对象：ServletContext-----------------
一个项目只有一个ServletContext对象，使用它可以在多个Servlet之间传递数据
命最长，和tomcat同生共死（在tomcat启动时就创建，在关闭时才消失）


可以用来：统计访问量


ServletContext的初始化参数：
	web.xml中:
		<context-param>
			<param-name>p1</param-name>
			<param-value>v1</param-value>
		</context-param>

	在servlet中获取初始化参数：
		ServletContext app=this.getServletContext();
		String value=app.getInitParameter("p1");

	每个servlet下的初始化参数，是只属于自己的。
	ServletContext的初始化参数，是公共的。




-----------server处理请求的流程-----------
server每次收到请求时，都会为这个请求开辟一个新的线程
server会把客户端的"请求数据"封装到request对象中
server还会创建response对象，它可以用来向客户端发送响应



-----------------response-----------------
响应头例子：
	HTTP/1.1 200 OK
	Date: Thu, 16 Nov 2017 01:53:37 GMT
	Content-Type: text/html
	Connection: keep-alive
	Last-Modified: Wed, 25 Oct 2017 15:22:44 GMT


response的类型为：HttpServletResponse
	ServletResponse --> 与协议无关的类型
	HttpServletResponse --> 与http协议相关的类型


状态码：
	200 成功
	302 重定向，会带着location
	304 缓存(将请求头中的if-modified-since的时间，与文件修改时间比较。如果近期没有修改，那么不返回内容，告诉浏览器从缓存里拿)
	404	页面不存在
	405 servlet中没有覆盖doGet、doPost方法
	500 服务器内部错误
发送状态码的方法：
	sendError(int sc) --> 发送错误状态码，例如404 500
	sendError(int sc,String msg) --> 发送错误状态码，带一个错误信息
	sendStatus(int sc) --> 发送成功的状态码，例如302
例子：
	response.sendError(404,"资源存在，但就是不给你看！");			


响应头：Content-Type、Refresh、Location等
设置响应头：
	setHeader(String name,String value)：
		response.setHeader("aaa","A");
	setIntHeader(String name,int value)：
		response.setIntHeader("Content_length",888);
	setDataHeader(String name,long value)：
		response.setDataHeader("expires",-1);

例子：【重定向】
	response.setHeader("Location", "/practice/Bservlet");
	response.setStatus(302);
	【快捷重定向】方法内部还是设置302，location
	response.sendRedirect('/practice/Bservlet');

例子：【定时刷新】可以理解为定时重定向
	response.setHeader("Refresh", "3;URL='/practice/Bservlet'");
	response.getWriter().print("will jump in 3 sec");

例子：【禁用缓存，开发阶段用】
	response.setHeader("Cache-Control", "no-cache");
	response.setHeader("pragma", "no-cache");
	response.setDateHeader("expires", -1);

html - head中的meta标签可以模拟响应头


响应体：通常是html，也可以是图片
response的两个流：不能同时使用，会报错
	ServletOutputStream：用来向客户端发送字节数据。（什么都能发，文字、图片）
		String txt="hello";
		byte[] bytes=txt.getBytes();
		ServletOutputStream stream=response.getOutputStream();
		stream.write(bytes);
	PrintWriter：用来向客户端发送字符数据，需要设置编码（只能发文字）
		response.setHeader("Content-Type","text/html;charset=utf-8");
		PrintWriter p=response.getWriter();



-----------------request-----------------
请求头例子：
	GET /login.html HTTP/1.1
	Connection: keep-alive
	User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36
	Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
	Referer: http://www.asdf.com/ 【从哪点过来的。用途：统计投放的广告有没有用、防盗链】
	Accept-Encoding: gzip, deflate, br
	Accept-Language: zh-CN,zh;q=0.8

获取常用信息：
	getRemoteAddr()：获取客户端的ip地址【封IP】
	getMethod()：获取请求方式

获取请求头：
	String getHeader(String name)
	int getIntHeader(String name)
	long getDateHeader(String name)

获取请求url：
	request.getScheme() 协议：http
	request.getServerName() 服务器名：localhost
	request.getServerPort() 端口：8080
	request.getContextPath() 项目名：practice
	request.getServletPath() servlet路径：/AServlet
	request.getQueryString() 参数部分，不包括问号：name=emily&psw=123456
	request.getRequestURI() 项目名+Servlet路径：/practice/AServlet
	request.getRequestURL() 不包含参数的整个请求路径：http://localhost:8080/practice/AServlet

获取请求参数：post的在请求体中，get的在url之后。获取方式完全相同
	String getParameter(String name);
	String[] getParameterValues(String name); form表单中的多选




-----------------域对象：Request域-----------------
请求转发：
	有时一个请求需要多个Servlet协作才能完成，所以需要从一个servlet跳到另一个servlet。在一个请求范围内，使用同一个request和response。通过request域来"交流"
	请求转发：由下一个servlet完成响应体，当前servlet只可以设置响应头（设置响应体会：无效果或者报错）

	RequestDispatcher rd=request.getRequestDispathcer("/BServlet");
	rd.forward(request,response);




-----------------请求转发&重定向-----------------
请求转发：
	一次请求 	
	地址栏不变	
	只能转发到本项目的其他servlet	
	是服务器行为，只需给出转发的servlet路径

重定向：
	两次请求	
	地址栏会变化 	
	可以定向到任意位置（百度）
	需要给出requestURI，即包含项目名



-----------------编码-----------------
1 响应编码
	response.setContentType("text/html;charset=utf-8");
	这一句不仅规定传给浏览器的时候使用utf-8编码；而且告诉浏览器需要用utf-8来解码
	是下面这句的简写方式：response.setHeader("Content-Type","text/html;charset=utf-8");

2 请求编码
	浏览器传来的参数是什么编码？
		在地址栏中直接输入参数：gbk，控制不了，不管
		在页面中点击：如果页面是utf-8，那么传递的参数就是utf-8
	tomcat默认使用iso来处理请求参数，会乱码
 		post：只需要在获取参数之前，request.setCharacterEncoding("utf-8");
 		get：比较麻烦
 			String name=request.getParameter("name");
 			byte[] bytes=name.getBytes("ISO-8859-1");
 			name=new String(bytes,"utf-8");



-----------------路径-----------------
以/开头：绝对路径
不以/开头：相对路径

1 servlet路径：web.xml中的<url-pattern>路径
	必须以*或/开头

2 请求转发的路径
	以/开头：是在项目内转发。所以绝对路径是以当前项目为起点 http://localhost:8080/项目名/
	不以/开头：相对当前servlet所在目录

3 重定向路径（是client端路径）
	以/开头：相对当前服务器 http://localhost:8080/

4 页面中的a和form路径
	与重定向相同，都是客户端路径，相对当前服务器 http://localhost:8080/




-----------------jsp的作用-----------------
servlet：
	优点：动态资源，可以编程
	缺点：设置html响应体很麻烦，需要大量的response.getWriter().print()
html：
	优点：写html很简单
	缺点：html是静态页面，不能包含动态信息
jsp(java server page)：
	优点：在原有html的基础上添加java脚本，构成jsp页面



-----------------jsp原理-----------------
jsp其实是一种特殊的servlet
	当jsp页面第一次（本次开启服务器后第一次）被访问时：
		服务器会把jsp编译成java文件（这个java其实是一个servlet类）
		然后再把java文件编译成.class
		然后创建该类对象
		最后调用它的service()方法
	第二次请求同一jsp时：
		直接调用service()方法

jsp文件对应的java文件和.class文件，存放在tomcat目录/work下





-----------------jsp的组成-----------------
jsp=html+java代码+jsp标签
jsp中无需创建即可使用的对象一共有9个，被称之为9大内置对象，例如：request对象、out对象
3种jsp脚本：
	<% %> 
	<%= %>	用于输出
	<%! %>
	<%-- --%> 注释，只存在于jsp文件中，服务器把jsp转换成.java时就已经忽略了注释，所以最终的页面中也不会有





-----------------jsp指令-----------------
1 page：
	<%@ page language="java"%>
	<%@ page import="java.util.*"%>
	<%@ page pageEncoding="UTF-8"%>
	<%@ page contentType="text/html; charset=UTF-8"%>

	import：导包
	pageEncoding：服务器把jsp编译成.java时用
	contentType：添加一个响应头，相当于response.setContentType("xx");

2 include：
	<%@ include file="b.jsp"%> 

	可以在jsp中插入多个外部文件（如：JSP、HTML、java程序，甚至是文本）。在转换成Servlet之前，include指令就会将相应的文件包含进主文件，然后一并转换成一个.java，编译生成一个.class，最后一起执行。
	作用：每个页面都有的内容提取出来
		1 header - footer
		2 引用的public文件

	【---------------------------------------

		记录：页面中固定不变的头、尾
			1 前端：js中生成，放在public.js中。（展示性的内容不推荐这样用，因为禁用js就显示不出来了）
			2 后端：头、尾用include引进来。（必须在IE8下测试，因为正常浏览器可以自动纠错，）

	  ---------------------------------------】


3 taglib：导入标签库
	<%@taglib prefix="pre" uri="/xxxxx"%>

	prefix：指定标签库在本页面中的前缀，自己起名字
	url：指定标签库的位置





-----------------jsp九大内置对象-----------------
1、request
2、response
3、session：会话
4、application：天地同寿
5、out：输出
6、pageContext
7、config 【用不着】
8、page 【用不着】
9、exception 【用不着】





-----------------jsp动作-----------------
http://www.runoob.com/jsp/jsp-actions.html





-----------------域对象：pageContext-----------------
只在当前jsp中有。（所以javaweb有四个域对象，而servlet只有三个，就是差这个）
作用："当前jsp页面"和"当前jsp页面中的标签"之间通信。

全域查找：pageContext.findAttribute("xxx") 从小到大，小域优先




-----------------cookie-----------------
cookie是http协议制定的。由服务器把cookie保存到浏览器，浏览器进行下一次请求时，把上次从服务器得到的cookie再归还给服务器。

javaWeb中使用cookie：
	Cookie cookie=new Cookie("name","emily");
	response.addCookie(cookie);

	Cookie[] arr = request.getCookies();
	if (arr != null) {
		for (Cookie c : arr) {
			out.print(c.getName() + ": " + c.getValue());
		}
	}

cookie的maxAge
	cookie.setMaxAge(60);
	maxAge>0：浏览器会把cookie保存到硬盘中，有效时间为maxAge秒（不是ms）
	maxAge<0：默认，cookie只在浏览器内存中存在；用户关闭浏览器时，cookie也消失了
	maxAge=0：浏览器会立刻删除cookie

cookie的path：
	cookie的path并不是设置这个cookie在用户的电脑硬盘中保存的位置
	cookie的path由服务器创建cookie时设置
	当浏览器访问服务器某个路径时，需要归还哪些cookie给服务器呢？这由cookie的path决定
	浏览器访问服务器的路径，如果包含某个cookie的路径，那么就会归还这个cookie
	cookie的默认path：当前访问文件的所在路径

如果cookie中要存取中文：
	// 存
	Cookie cookie=new Cookie("username",java.net.URLEncoder.encode(name,"utf-8") );
	// 取
	name=java.net.URLDecoder.decode(cookie.getValue(),"utf-8");




-----------------域对象：HttpSession-----------------
HttpSession是由javaWeb提供的，http协议中没有。
session是服务器端对象，保存在服务器。
session底层依赖cookie或者url重写，cookie不能跨浏览器，所以session也不能。 

会话：一个用户对服务器的连贯请求（连贯：中途没有关闭浏览器）

得到session对象：
	servlet中：
		HttpSession session=request.getSession();
	jsp中：是内置对象
		<% 
			session.getAttribute("name");
		%>

用途：
	1 登录状态
		登录成功之后添加session
		其他所有页面先验证session
	2 数据先存数据库，然后再存放到session中。存放到session的目的，是为了读取的时候更快，不用去读数据库


session的原理：
	http://blog.csdn.net/sunny2come/article/details/7545420

session的其他方法：
	void invalidate()：让session失效，"用户退出/注销"时用
	
web.xml中配置session的最大不活动时间：15min
	<session-config>
		<session-timeout>15</session-timeout>
	</session-config>

如果客户禁用了cookie，那么：
	1 提示用户"浏览器安全等级过高，请..."。放弃给其httpSession
	2 使用url重写：http://blog.csdn.net/u014753393/article/details/49634813




-----------------登录/注册时的验证码-----------------
思路分析：
	1 利用session
	2 验证码图片要动态从后台获取。img的src写VCodeServlet的地址
	  VCodeServlet：
	  	生成新图片，返回。
	  	把新生成的txt放到session中
	3 "看不清，换一张"：
		img的src重新赋一遍值。为了防止缓存，把时间戳当成参数来偏偏浏览器
	4 判断验证码输入：
		取session不能在前台，不安全。所以要在后台取并判断




-----------------BeanUtils-----------------

	BeanUtils.setProperty(bean, "name", "张三");
	String name=BeanUtils.getProperty(bean, "name");

把map的数据封装到一个javaBean中，要求map的key与bean的属性名相同：
	BeanUtils.populate(user,map);




-----------------EL标签-----------------
作用：替代<%= %>，也就是说EL只能做输出

用法：
	${user.name}
	${user["hahaha-name"]}
	${cookie.JSESSIONID.value} cookie是EL中的内置对象，cookie.key返回对应的Cookie对象（而不是key对应的value值）

指定域：
	PageScope.xx
	RequestScope.xx
	SessionScope.xx
	ApplicationScope.xx

全域查找：
	没指定域时，依序从Page、Request、Session、Application范围查找。
	都没找到，返回""，而不是null

具体：https://www.cnblogs.com/xdp-gacl/p/3938361.html


JSTL：JSP标准标签库  http://www.runoob.com/jsp/jsp-jstl.html




-----------------MVC-----------------
MVC不是java独有，所有BS结构的项目都在用。

M 	model		模型
V 	view		视图(jsp)
C 	controller	控制器(servlet)




-----------------javaWeb三层框架-----------------
是java独有的。

web层：与web相关的内容(servlet jsp request、response、session等)
业务层：service
数据层：操作数据库

不要污染service层：独立。不能和web有关，不能和数据库有关。专注逻辑、功能




-----------------思想：面向接口编程-----------------
举例：
	目的：降低service层的耦合度
	把规范和实现分开

	UserService.java -- 接口（规范）
	UserServiceImpl.java -- 具体实现

	要面向接口编程，不管具体的impl。impl只要遵循规范，就可以随时换。

	所以代码中要避免出现impl，new UserServiceImpl()不能用了。
	把impl放在配置文件中，用反射来加载，而不能写在代码里。




----------------复习-----------------
> ServletContext
	与天地同寿：在服务器启动时生，关闭时死。每个项目只会有一个

> HttpSession
	每个项目可能有多个session，也可能没有（没人访问）
	不是访问任何servlet都会创建session，只有使用了request.getSession()才会创建session。
	访问jsp一定会创建session，因为jsp转servlet的过程中写了getSession()
	访问静态资源不会创建

> ServletRequest
	处在同一个request中时，多个servlet/jsp之间传递信息：请求转发
	请求动态资源时创建
	请求静态资源时不会创建



-----------------监听器Listener-----------------
javaWeb三大组件：
	servlet
	listener
	filter

监听器特点：
	1 是借口，内容需要自己实现
	2 它需要注册，例如注册在某个按钮上
	3 监听器中的方法，会在特定事件发生时被调用


监听器的事件源：
	> ServletContext
		> 生命周期监听：ServletContextListener接口,它有两个方法,分别在出生、死亡时调用
			> void contextInitialized(ServletContextEvent sce)：出生时触发。写一些在tomcat启动时就执行的代码，比如插入初始化数据
			> void contextDestyoyed(ServletContextEvent sce)：死亡时触发
		> 属性监听：ServletContextAttributeListener接口,它有三个方法,分别在添加、替换、删除属性时调用
			> void attributeAdded(ServletContextAttributeEvent event)
			> void attributeRemoved(ServletContextAttributeEvent event)
			> void attributeReplaced(ServletContextAttributeEvent event)

	> HttpSession
		> 生命周期监听：HttpSessionListener接口
			> void sessionCreated(HttpSessionEvent se);
			> void sessionDestroyed(HttpSessionEvent se);
		> 属性监听：HttpSessionAttributeListener接口（类似）

	> ServletRequest()
		> 生命周期监听：ServletRequestListener接口
			> void requestInitialized(ServletRequestEvent se);
			> void requestDestroyed(ServletRequestEvent se);
		> 属性监听：ServletRequestAttributeListener接口（类似）


怎么写监听器？
	写一个监听器类，要求实现某个监听器接口
	注册：在web.xml中配置来完成注册
		<listener>
			<listener-class>完整路径</listener-class>
		</listener>


事件对象：
	> ServletContextEvent
		> ServletContext getServletContext();
	> HttpSessionEvent
		> HttpSession getSession();
	> ServletRequestEvent
		> ServletContext getServletContext();
		> ServletRequest getServletRequest()
	> ServletContextAttributeEvent scab（另两个属性监听类似）
		> ServletContext getServletContext();
		> String getName() 
		> Object getValue() 获取的是旧值
		> 获取新值：scab.getServletContext().getAttriute(scab.getName())


session的感知监听：
	> 都是session相关
	> 用来添加到javaBean上，而不是加到三大域上。
	> 都不需要在web.xml中配置
