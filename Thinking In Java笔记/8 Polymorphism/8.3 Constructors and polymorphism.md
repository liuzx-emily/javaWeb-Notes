构造函数 constructor 是 implicitly **static** 函数，所以 constructor **不是 polymorphic** 。



    package lzx;    
    import static abc.Print.*;
    
    class Meal {
    	Meal() {
    		print("Meal()");
    	}
    }
    
    class Bread {
    	Bread() {
    		print("Bread()");
    	}
    }
    
    class Cheese {
    	Cheese() {
    		print("Cheese()");
    	}
    }
    
    class Lunch extends Meal {
    	Lunch() {
    		print("Lunch()");
    	}
    }
    
    class PortableLunch extends Lunch {
    	PortableLunch() {
    		print("PortableLunch()");
    	}
    }
    
    public class Sandwich extends PortableLunch {
    	private Bread b = new Bread();
    	private Cheese c = new Cheese();
    
    	public Sandwich() {
    		print("Sandwich()");
    	}
    
    	public static void main(String[] args) {
    		new Sandwich();
    	}
    }
    输出:
    Meal()
    Lunch()
    PortableLunch()
    Bread()
    Cheese()
    Sandwich()

---
    package lzx;    
    import static abc.Print.*;
    
    class Animal {
    	private static int animalNum = 0;
    	private static int animalCute = 0;
    	private final int animalId;
    	private final int cute;
    
    	Animal(int cute) {
    		animalNum += 1;
    		animalCute += cute;
    		animalId = animalNum;
    		this.cute = cute;
    	}
    
    	public void Animal_dispose() {
    		animalNum -= 1;
    		animalCute -= cute;
    		System.out.print("第" + animalId + "个小动物被领养走了，是一个");
    		if (cute == 5) {
    			print("小狗狗！");
    		} else {
    			print("小猫咪！");
    		}
    		if (animalNum == 0 && animalCute == 0) {
    			print("没有小动物了！");
    		}
    	}
    }
    
    class Dog {
    	private Animal animal = new Animal(5);
    	public void Dog_dispose(){
    		animal.Animal_dispose();
    	}
    }
    
    class Cat {
    	private Animal animal = new Animal(3);
    	public void Cat_dispose(){
    		animal.Animal_dispose();
    	}
    }
    
    public class Pet {
    	public static void main(String[] args) {
    		Dog[] dogs = { new Dog(), new Dog(), new Dog() };
    		Cat[] cats={new Cat(),new Cat(),new Cat()};
    		dogs[2].Dog_dispose();
    		for(Cat cat:cats){
    			cat.Cat_dispose();
    		}
    		dogs[0].Dog_dispose();
    		dogs[1].Dog_dispose();
    	}
    }
    输出：
    第3个小动物被领养走了，是一个小狗狗！
    第4个小动物被领养走了，是一个小猫咪！
    第5个小动物被领养走了，是一个小猫咪！
    第6个小动物被领养走了，是一个小猫咪！
    第1个小动物被领养走了，是一个小狗狗！
    第2个小动物被领养走了，是一个小狗狗！
    没有小动物了！

---
下面的程序bug极难发现：

    package lzx;    
    import static abc.Print.*;
    
    class Glyph {
    	void draw() {
    		print("Glyph.draw()");
    	}
    
    	Glyph() {
    		print("Glyph() before draw()");
    		draw();
    		print("Glyph() after draw()");
    	}
    }
    
    class RoundGlyph extends Glyph {
    	private int radius = 1;
    
    	RoundGlyph(int r) {
    		radius = r;
    		print("RoundGlyph.RoundGlyph(), radius = " + radius);
    	}
    
    	void draw() {
    		print("RoundGlyph.draw(), radius = " + radius);
    	}
    }
    
    public class PolyConstructors {
    	public static void main(String[] args) {
    		new RoundGlyph(5);
    	}
    }
    输出：
    Glyph() before draw()
    RoundGlyph.draw(), radius = 0
    Glyph() after draw()
    RoundGlyph.RoundGlyph(), radius = 5
输出的结果和我们预想的不同。

初始化的实际过程：  
(1) 在采取其他任何操作之前，the storage allocated for the object is initialized to binary zero  
(2) 调用 base-class 的constructor。此时，RoundGlyph 中的draw()方法会得到调用（在RoundGlyph的constructor调用之前）。此时会发现 radius的值为 0，这是由于步骤(1)造成的。  
(3) Member initializers are called in the order of declaration.  
(4) 调用衍生类constructor  

为了避免这类bug：  
**不要在constructor中调用函数**（final或者private可以安全地在constructor中调用，因为它们不会被override）