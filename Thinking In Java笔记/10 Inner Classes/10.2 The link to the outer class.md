    //:lzx/A.java
    package lzx;
    
    //import static abc.Print.*;
    
    interface Selector {
    	boolean end();
    
    	Object current();
    
    	void next();
    }
    
    class Sequence {
    	private Object[] items;
    	private int next = 0;
    
    	public Sequence(int size) {
    		items = new Object[size];
    	}
    
    	public void add(Object x) {
    		if (next < items.length)
    			items[next++] = x;
    	}
    
    	private class SequenceSelector implements Selector {
    		private int i = 0;
    
    		public boolean end() {
    			return i == items.length;
    		}
    
    		public Object current() {
    			return items[i];
    		}
    
    		public void next() {
    			if (i < items.length)
    				i++;
    		}
    	}
    
    	public Selector selector() {
    		return new SequenceSelector();
    	}
    
    }
    
    public class A {
    	public static void main(String[] args) {
    		Sequence sequence = new Sequence(10);
    		for (int i = 0; i < 10; i++)
    			sequence.add(Integer.toString(i));
    		Selector selector = sequence.selector();
    		while (!selector.end()) {
    			System.out.print(selector.current() + " ");
    			selector.next();
    		}
    	}
    }


So **an inner class has automatic access to the members of the enclosing class**. How can this
happen?   
The inner class secretly captures a reference to the particular object of the enclosing
class that was responsible for creating it. Then, when you refer to a member of the enclosing
class, that reference is used to select that member. Fortunately, the compiler takes care of all
these details for you, but now you can see that an object of an inner class can be created only
in association with an object of the enclosing class (when, as you shall see, the inner class is
non-static). Construction of the inner-class object requires the reference to the object of the
enclosing class, and the compiler will complain if it cannot access that reference. Most of the
time this occurs without any intervention on the part of the programmer.


---

    //:lzx/A.java
    package lzx;
    
    //import static abc.Print.*;
    
    interface Selector {
    	boolean end();
    
    	Object current();
    
    	void next();
    }
    
    class Text {
    	private String text;
    
    	Text(String text) {
    		this.text = text;
    	}
    
    	public String toString() {
    		return text;
    	}
    }
    
    class StringSequence {
    	private Text t;
    	private int length;
    
    	StringSequence(String s) {
    		t = new Text(s);
    		length = t.toString().length();
    	}
    
    	private class SequenceSelector implements Selector {
    		private int now = 0;
    
    		public boolean end() {
    			return now == length;
    		}
    
    		public Object current() {
    			return t.toString().toCharArray()[now];
    		}
    
    		public void next() {
    			if (now < length) {
    				now++;
    			}
    		}
    	}
    
    	public SequenceSelector getSS() {
    		return new SequenceSelector();
    	}
    }
    
    public class A {
    	public static void main(String[] args) {
    		StringSequence ss1 = new StringSequence("哈利路亚moha");
    		Selector s = ss1.getSS();
    		while (!s.end()) {
    			System.out.println(s.current());
    			s.next();
    		}
    	}
    }

备注：

如果 SequenceSelector  类**没有**被设定为 private 的，则 main 函数中可以写成：

	StringSequence.SequenceSelector s = ss1.getSS();
现在被设定为private，就不能这么写了，不然会报错：

	The type StringSequence.SequenceSelector is not visible

因为 main 函数和 SequenceSelector 类不在同一个类里（main在类A里， SequenceSelector  在类 StringSequence 中）

