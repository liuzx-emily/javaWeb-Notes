注意清楚的顺序：与创建相反。  比如：一个基础classA和一个继承class B，  
在创建时，需要先A后B。  
在清除时，需要先B后A。

---
如果 Java 基础类有一个方法名被“重载”使用多次，在衍生类里对那个方法名的重新定义就不会隐藏任何基础类的版本。

    import static lzx.Print.print;
    
    class Homer {
    	char doh(char c) {
    		print("doh(char)");
    		return 'd';
    	}
    
    	float doh(float f) {
    		print("doh(float)");
    		return 1.0f;
    	}
    }
    
    class Milhouse {
    }
    
    class Bart extends Homer {
    	void doh(Milhouse m) {
    		print("doh(Milhouse)");
    	}
    }
    
    public class Hide {
    	public static void main(String[] args) {
    		Bart b = new Bart();
    		b.doh(1);
    		b.doh('x');
    		b.doh(1.0f);
    		b.doh(new Milhouse());
    	}
    }
output：

    doh(float)
    doh(char)
    doh(float)
    doh(Milhouse)

Java SE5 has added the **@Override** annotation, which is not a keyword but can be used as if it were. When you mean to override a method, you can choose to add this annotation and the compiler will produce an error message if you  accidentally overload instead of overriding.
【override覆盖；overload重载】
    
    //: reusing/Lisa.java
    // {CompileTimeError} (Won’t compile)
    class Lisa extends Homer {
    	@Override
    	void doh(Milhouse m) {
    		System.out.println("doh(Milhouse)");
    	}
    }


The {CompileTimeError} tag excludes the file from this book’s Ant build, but if you compile it by hand you’ll see the error message:

    method does not override a method from its superclass
The @**Override** annotation will thus prevent you from accidentally overloading when you don’t mean to.