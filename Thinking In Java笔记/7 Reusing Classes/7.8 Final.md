# 1. final data #

1.编译期常数：在编译的时候就知道值，编译器将值自动带入到所有表达式中计算。java中只有primitive才可能是编译期常数。

2.运行期常数：编译的时候不知道值。在运行期初始化，并且不能修改。
如果一个对象的引用是final，则它只能指向某个对象，而对象本身可以改。

By convention, **fields** that are both **static** and **final** are capitalized and use underscores to separate words.


    import static lzx.Print.print;
    import java.util.*;    
    
    class Value {
    	int i; // Package access
    
    	public Value(int i) {
    		this.i = i;
    	}
    }
    
    public class FinalData {
    	private static Random rand = new Random(47);
    	private String id;
    
    	public FinalData(String id) {
    		this.id = id;
    	}
    
    	// Can be compile-time constants:
    	private final int valueOne = 9;
    	private static final int VALUE_TWO = 99;

    	// Typical public constant:
    	public static final int VALUE_THREE = 39;

    	// Cannot be compile-time constants:
    	private final int i4 = rand.nextInt(20);
    	static final int INT_5 = rand.nextInt(20);
    	private Value v1 = new Value(11);
    	private final Value v2 = new Value(22);
    	private static final Value VAL_3 = new Value(33);

    	// Arrays:
    	private final int[] a = { 1, 2, 3, 4, 5, 6 };
    
    	public String toString() {
    		return id + ": " + "i4 = " + i4 + ", INT_5 = " + INT_5;
    	}
    
    	public static void main(String[] args) {
    		FinalData fd1 = new FinalData("fd1");
    		// ! fd1.valueOne++; // Error: can’t change value
    		fd1.v2.i++; // Object isn’t constant!
    		fd1.v1 = new Value(9); // OK -- not final
    		for (int i = 0; i < fd1.a.length; i++)
    			fd1.a[i]++; // Object isn’t constant!
    		// ! fd1.v2 = new Value(0); // Error: Can’t
    		// ! fd1.VAL_3 = new Value(1); // change reference
    		// ! fd1.a = new int[3];
    		print(fd1);
    		print("Creating new FinalData");
    		FinalData fd2 = new FinalData("fd2");
    		print(fd1);
    		print(fd2);
    	}
    }
输出：

    fd1: i4 = 15, INT_5 = 18
    Creating new FinalData
    fd1: i4 = 15, INT_5 = 18
    fd2: i4 = 13, INT_5 = 18
    
### blank final
    
    package lzx;
    class Poppet {
    	private int i;
    
    	Poppet(int ii) {
    		i = ii;
    	}
    }
    
    public class BlankFinal {
    	private final int i = 0; // Initialized final
    	private final int j; // Blank final
    	private final Poppet p; // Blank final reference
    	
    
    	public BlankFinal() {
    		j = 1; // Initialize blank final
    		p = new Poppet(1); // Initialize blank final reference
    	}
    
    	public BlankFinal(int x) {
    		j = x; // Initialize blank final
    		p = new Poppet(x); // Initialize blank final reference
    	}
    
    	public static void main(String[] args) {
    		new BlankFinal();
    		new BlankFinal(47);
    	}
    }
Blank finals MUST be initialized in the constructor:

### final arguments 

    class Gizmo {
    	public void spin() {
    	}
    }
    
    class FinalArguments {
    	void with(final Gizmo g) {
    		// ! g = new Gizmo(); // Illegal -- g is final
    	}
    
    	void without(Gizmo g) {
    		g = new Gizmo(); // OK -- g not final
    		g.spin();
    	}
    
    	void f(final int i) {
    		// i++;
    	}
    	int g(final int i) {
    		return i + 1;
    	}
    }

---
# 2. final method #


使用final method原本有两个原因：  
1.防止继承类中override  
2.提高efficency


With Java SE5/6, you should let the compiler and JVM handle **efficiency** issues and make a method final only if you want to explicitly **prevent overriding**.

基础类中的private函数不能被类外任何东西调用（无论是它的继承类还是别的）。继承类“不能继承”基础类中的private函数，所以也就提不上override。所以可以说private函数是默认为final的（不能被override）。  
可以手动给private函数加上final，但没什么意义。如下：


    class WithFinals {
    	// Identical to "private" alone:
    	private final void f() {
    		print("WithFinals.f()");
    	}
    
    	// Also automatically "final":
    	private void g() {
    		print("WithFinals.g()");
    	}
    }
    
    class OverridingPrivate extends WithFinals {
    	public final void f() {
    		print("OverridingPrivate.f()");
    	}
    
    	public void g() {
    		print("OverridingPrivate.g()");
    	}
    }
    
    
    
    public class FinalOverridingIllusion {
    	public static void main(String[] args) {
    		OverridingPrivate op2 = new OverridingPrivate();
    		op2.f();
    		op2.g();
    		// You can upcast:
    		WithFinals wf = op2;
    		// But you can’t call the methods:
    		// ! wf.f();
    		// ! wf.g();
    	}
    }


# 3. final class 
禁止继承