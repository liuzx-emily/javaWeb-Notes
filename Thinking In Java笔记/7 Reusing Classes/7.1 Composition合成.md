    class WaterSource {
    	private String s=new String("Constructed");
    
    	public String toString() {
    		return s;
    	}
    }
    
    public class SprinklerSystem {
    	private String valve;
    	float f;
    	WaterSource source;
    
    	void print() {
    		System.out.println("valve = " + valve);
    		System.out.println("f = " + f);
    		System.out.println("source = " + source);
    
    	}
    
    	public static void main(String[] args) {
    		SprinklerSystem x = new SprinklerSystem();
    		x.print();
    	}
    }
output：
    
    valve = null
    f = 0.0
    source = null
    

WaterSource的一个method比较特别：toString ()。大家不久就会知道，所有non-primitive 
object 都有一个toString() 方法。当编译器本来希望一个String，但却获得非String对象时，就会调用这个方法。所以在下面这个表达式中：

    System.out.println("source = " + source) ;

the compiler sees you trying to add a **String** object ("source = ") to a **WaterSource**. Because you can only “add” a **String** to another **String**, it says “I’ll turn **source** into a **String** by calling **toString**( )!”   
After doing this it can combine the two Strings and pass the resulting String to System.out.println( ) . Any time you want to allow this behavior with a class you create, you need only write a **toString**( ) method.

---
**Primitives that are fields in a class** are automatically initialized to **zero**.   
But **the object references** are initialized to **null**, and if you try to call methods for any of them, you’ll get an exception-a runtime error. Conveniently, you can still print a null reference without throwing an exception.  

It makes sense that the compiler doesn’t just create a default object for every reference, because that would incur unnecessary overhead in many cases. If you want the references initialized, you can:

1. At the point the objects are defined. This means that they’ll always be initialized before the constructor is called.
 
2. In the constructor for that class.

3. Right before you actually need to use the object. This is often called lazy
initialization. It can reduce overhead in situations where object creation is expensive and the object doesn’t need to be created every time.

4. Using instance initialization.