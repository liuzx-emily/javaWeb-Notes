创建新class 时，如果没有明确说明从哪个class 继承。则会implicitly 从java的标准根类**Object** 继承
 
    
    //: reusing/Detergent.java
    // Inheritance syntax & properties.
    import static lzx.Print.print;
    
    class Cleanser {
    	private String s = "Cleanser";
    
    	public void append(String a) {
    		s += a;
    	}
    
    	public void apply() {
    		append(" apply()");
    	}
    
    	public void scrub() {
    		append(" scrub()");
    	}
    
    	public String toString() {
    		return s;
    	}
    
    	public static void main(String[] args) {
    		Cleanser x = new Cleanser();
    		x.apply();
    		x.scrub();
    		print(x);
    	}
    }
    
    public class Detergent extends Cleanser {
    	// Change a method:
    	public void scrub() {
    		append(" Detergent.scrub()");
    		super.scrub(); // Call base-class version
    	}
    
    	// Add methods to the interface:
    	public void foam() {
    		append(" foam()");
    	}
    
    	// Test the new class:
    	public static void main(String[] args) {
    		Detergent x = new Detergent();
    		x.apply();
    		x.scrub();
    		x.foam();
    		print(x);
    		print("Testing base class:");
    		Cleanser.main(args);
    	}
    }
output：    

    Cleanser apply() Detergent.scrub() scrub() foam()
    Testing base class:
    Cleanser apply() scrub()



both Cleanser and Detergent contain a main( ) method. You can create a main( ) for each one of your classes; this technique of putting a main() in each class allows easy testing for each class. And you don’t need to remove the main() when you’re finished;you can leave it in for later testing.  

Even if you have a lot of classes in a program, only the main( ) for the class invoked on the command line will be called. So in this case, when you say 

`java Detergent`  
**Detergent.main( )** will be called. But you can also say 

`java Cleanser`   
to invoke **Cleanser.main( )**, even though Cleanser is not a public class. **Even if a class has package access, a public main() is accessible.**  

Here, you can see that **Detergent.main( )** calls **Cleanser.main( )** explicitly, passing it the same arguments from the command line (however, you could pass it any String array).  

---
to allow for inheritance, as a general rule make all **fields** private and all methods **public**.(protected也行)  
（如果没有指定access specifier，那么class member是package access。那么package外的类，就不能继承package access的成员了。

---
keyword：**super**

    	public void scrub() {
    		append(" Detergent.scrub()");
    		super.scrub(); // Call base-class version
    	}
#Initializing the base class

当创建一个衍生类的object时，同时也创建了一个基础类的subobject，包含在object中。

当然，基础类的subobject应该正确地初始化。在衍生类的constructor中，Java 会**自动插入对基础类constructor的调用**。


    //: reusing/Cartoon.java
    // Constructor calls during inheritance.
    import static lzx.Print.print;
    
    class Art {
    	Art() {
    		print("Art constructor");
    	}
    }
    
    class Drawing extends Art {
    	Drawing() {
    		print("Drawing constructor");
    	}
    }
    
    public class Cartoon extends Drawing {
    	public Cartoon() {
    		print("Cartoon constructor");
    	}
    
    	public static void main(String[] args) {
    		Cartoon x = new Cartoon();
    	}
    }
   output：
    
    Art constructor
    Drawing constructor
    Cartoon constructor

---

    import static lzx.Print.print;
    
    class Art {
    	Art() {
    		print("Art constructor");
    	}
    }
    
    class Drawing{
    	Drawing() {
    		print("Drawing constructor");
    	}
    }
    
    public class Cartoon extends Art {
    	Drawing d=new Drawing();
    	Cartoon(){
    		print("Cartoon的构造函数");
    	}
    
    	public static void main(String[] args) {
    		Cartoon x = new Cartoon();
    	}
    }
output：【易错】
    
    Art constructor
    Drawing constructor
    Cartoon的构造函数

---
有参数的constructor

    import static lzx.Print.print;
    
    class Game {
    	Game(int i) {
    		print("Game constructor");
    	}
    }
    
    class BoardGame extends Game {
    	BoardGame(int i) {
    		super(i);
    		print("BoardGame constructor");
    	}
    }
    
    public class Chess extends BoardGame {
    	Chess() {
    		super(11);
    		print("Chess constructor");
    	}
    
    	public static void main(String[] args) {
    		Chess x = new Chess();
    	}
    }

基础类没有no-arg的constructor时，再衍生类的constructor里必须明确调用基础类的有arg的constructor，不然会报错：  
keyword : **super**

    BoardGame(int i) {
    		super(i);
    		print("BoardGame constructor");
    	}

例子：

    import static lzx.Print.print;
    
    public class stem extends root {
    	component1 c1 = new component1();
    	component2 c2 = new component2();
    	component3 c3 = new component3();
    	stem(){
    		print("stem");
    	}
    	public static void main(String[] args) {
    		stem sstem=new stem();
    	}
    }
    
    class root {
    	root(){
    		print("root");
    	}
    	component1 c1 = new component1();
    	component2 c2 = new component2();
    	component3 c3 = new component3();
    }
    
    class component1 {
    	component1() {
    		print("component1");
    	}
    }
    
    class component2 {
    	component2() {
    		print("component2");
    	}
    }
    
    class component3 {
    	component3() {
    		print("component3");
    	}
    }
结果:

    component1
    component2
    component3
    root
    component1
    component2
    component3
    stem

结果说明：
创建一个衍生类的object时：
	
- 调用基础类的constructor
- 进行衍生类的member初始化（在定义初初始化的）
- 衍生类的constructor

例子：

    import static lzx.Print.print;
    
    public class stem extends root {
    	component1 c1 = new component1();
    	component1 c11;
    
    	stem() {
    		print("stem");
    	}
    
    	{
    		print("dada");
    		c11 = new component1();
    		print("lala");
    	}
    
    	public static void main(String[] args) {
    		stem sstem = new stem();
    	}
    }
    
    class root {
    	root() {
    		print("root");
    	}
    
    	component1 c1 = new component1();
    }
    
    class component1 {
    	component1() {
    		print("component1");
    	}
    }
结果：

    component1
    root
    component1
    dada
    component1
    lala
    stem
 
结果说明：  
创建一个衍生类的object时：
	
- 调用基础类root的constructor
- 进行衍生类的member初始化（在定义处初始化的）
- 进行衍生类的member初始化

    	{
    		print("dada");
    		c11 = new component1();
    		print("lala");
    	}
- 最后才是衍生类的constructor