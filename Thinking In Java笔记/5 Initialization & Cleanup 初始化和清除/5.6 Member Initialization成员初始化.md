# Member initialization #
Java goes out of its way to guarantee that variables are properly initialized before they are used. 

---
In the case of a **method’s local variables**, this guarantee comes in the form of a compile-time error.   

So if you say:

    void f() {
    	int i;
    	i++; 	// Error -- i not initialized
    }
you’ll get an error message that says that i might not have been initialized.  

Of course, the compiler could have given i a default value, but an uninitialized local variable is probably a programmer error, and a default value would have covered that up. Forcing the programmer to provide an initialization value is more likely to catch a bug.  

---
**If a primitive is a field in a class**, however, things are a bit different. As you saw in the *Everything Is an Object* chapter, each primitive field of a class is guaranteed to get an initial value.   

Here’s a program that verifies this, and shows the values:

    //: initialization/InitialValues.java
    // Shows default initial values.
    import static net.mindview.util.Print.*;
    
    public class InitialValues {
    	boolean t;
    	char c;
    	byte b;
    	short s;
    	int i;
    	long l;
    	float f;
    	double d;
    	InitialValues reference;
    
    	void printInitialValues() {
    		print("Data type Initial value");
    		print("boolean " + t);
    		print("char [" + c + "]");
    		print("byte " + b);
    		print("short " + s);
    		print("int " + i);
    		print("long " + l);
    		print("float " + f);
    		print("double " + d);
    		print("reference " + reference);
    	}
    
    	public static void main(String[] args) {
    		InitialValues iv = new InitialValues();
    		iv.printInitialValues();
    		/*
    		 * You could also say: new InitialValues().printInitialValues();
    		 */
    	}
    }

output:

    Data type 		Initial value
    boolean			 false
    char			 [ ]
    byte			 0
    short 			 0
    int 			 0
    long 		  	 0
    float 			 0.0
    double 			 0.0
    reference		 null

You can see that even though the values are not specified, they automatically get initialized (the char value is a zero, which prints as a space). So at least there’s no threat of working with uninitialized variables.  

---
When you define **an object reference inside a class** without initializing it to a new object, that reference is given a special value of **null** .


    