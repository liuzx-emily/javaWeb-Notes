## To define an array reference 定义数组引用


    int a1[];
    int[] a1;  //推荐使用这一种,更合理

两种都可以。第一种和c、c++的方式相同；但第二种is probablya more sensible syntax。  

a1是a reference to an array，不是数组本身  
 
编译器**不允许**我们指定数组的大小。  
## Array Initialization 数组初始化

All that you have at this point is **a reference to an array** (you’ve allocated
enough storage **for that reference**), and there’s been **no space allocated for the array object itself**.  

**To create storage for the array, you must write an initialization expression.
For arrays,initialization can appear anywhere in your code, but you can also use a special kind of initialization expression that must occur at the point where the array is created：**

The storage allocation (the equivalent of using new) is taken care of by the compiler in this case. For example:

    int[] a1 = { 1, 2, 3, 4, 5 };

---
So why would you ever define an array reference without an array?

    int[] a2;
Well, it’s possible to assign one array to another in Java, so you can say:

    a2 = a1;
What you’re really doing is **copying a reference**

    public class Question {
    	public static void main(String[] args) {
    		int[] a1 = { 1, 2, 3, 4, 5 };
    		int[] a2;
    		a2 = a1;
    		a2[0] = 10;
    		System.out.println("a1[0]="+a1[0]);
    	}
    }
output：

    a1[0]=10
	//Since a2 and a1 are then aliased to the same array, 
	//the changes made via a2 are seen in a1.

## 下标 
所有数组（无论它们是arrays of primitives还是arrays of object）都有一个intrinsic member，叫length。利用length可以知道数组内包含了多少个元素。  
> 索引越界怎么办？   [0,length-1]
 
- C和C++:会“默默”地接受，并允许我们胡乱使用自己的内存，这正是许多程序错误的根源。  

- java：一旦越界，就生成一个runtime error。   
Of course, checking every array access **costs time and code** and there’s **no way to turn it off**, which means that **array accesses might be a source of inefficiency in your program** if they occur at a critical juncture.   
For **Internet security** and **programmer productivity**, the Java designers saw that this was **a worthwhile trade-off**. Although you may be tempted to write code that you think might make array accesses more efficient, this is a waste of time because automatic compile-time and runtime optimizations will speed array accesses.

##What if you don’t know how many elements you’re going to need in your array while you’re writing the program?
You simply use **new** to create the elements in the array. Here, new works even though it’s creating an array of primitives (new won’t create a non-array primitive):  

> new能创建object，不能创建primitive数据；  
> 但是new可以创建primitive数据的数组

    import java.util.*;
    
    public class ArrayNew {
    	public static void main(String[] args) {
    		int[] a;
    		Random rand = new Random(47);
    		a = new int[rand.nextInt(20)];
    		System.out.println("length of a = " + a.length);
    		System.out.println(Arrays.toString(a));
			//The Arrays.toString( ) method, which is part of the standard 
			//java.util library, produces a printable version of a one-
			//dimensional array.
    	}
    }
	
output：

	length of a = 18
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]


The size of the array is chosen at random by using the Random.nextInt( ) method, which produces a value between zero and that of its argument. Because of the randomness, it’s clear that array creation is actually happening at **run time**.

In addition, the output of this program shows that **array elements of primitive types are automatically initialized to “empty” values**. (For numerics and char, this is zero, and for boolean, it’s false.)

Of course, in this case the array could also have been defined and initialized in the same statement:
    
	int[] a = new int[rand.nextInt(20)];
This is the preferred way to do it, if you can.
##Non-primitive Array
If you create a non-primitive array, you create **an array of references**. 

Consider the wrapper type Integer, which is a class and not a primitive:

    import java.util.*;
    
    public class ArrayClassObj {
    	public static void main(String[] args) {
    		Random rand = new Random(47);
    		Integer[] a = new Integer[rand.nextInt(20)];
    		System.out.println("length of a = " + a.length);
    		for (int i = 0; i < a.length; i++)
    			a[i] = rand.nextInt(500); // Autoboxing
    		System.out.println(Arrays.toString(a));
    	}
    }
output：

    length of a = 18
    [55, 193, 361, 461, 429, 368, 200, 22, 207, 288, 128, 51, 89, 309, 278, 498, 361, 20]
Here, **even after new is called to create the array**:

    Integer[] a = new Integer[rand.nextInt(20)];
**it’s only an array of references, and the initialization is not complete until the reference itself is initialized by creating a new Integer object** (via autoboxing, in this case):

	a[i] = rand.nextInt(500);

If you forget to create the object, however, you’ll  get **an exception at run time** when you try to use the empty array location.

##可以用｛｝初始化“对象数组”


    //: initialization/ArrayInit.java
    // Array initialization.
    import java.util.*;
    
    public class ArrayInit {
    	public static void main(String[] args) {
    		Integer[] a = { new Integer(1), new Integer(2),};
    		Integer[] b = new Integer[] { new Integer(1), new Integer(2),};
    		System.out.println(Arrays.toString(a));
    		System.out.println(Arrays.toString(b));
    	}
    }
In both cases, **the final comma in the list of initializers is optional**. (This feature makes for easier maintenance of long lists.)

Although the first form is useful, it’s more limited because it can only be used at the point where the array is defined. You can use the second forms anywhere, even inside a method call.   

For example, you could create an array of String objects to pass to the main( )
of another method, to provide alternate command-line arguments to that main( ):
    public class DynamicArray {
    	public static void main(String[] args) {
    		Other.main(new String[] { "fiddle", "de", "dum" });
    	}
    }
    
    class Other {
    	public static void main(String[] args) {
    		for (String s : args)
    			System.out.print(s + " ");
    	}
    }

The array created for the argument of Other.main( ) is created at the point of the method call, so you can even provide alternate arguments at the time of the call.



#Variable argument lists 可变参数列表
Since all classes are ultimately inherited from the common root class **Object** , you can create a method that takes an array of Object and call it like this:

	class A {
    }
    
    public class VarArgs {
    	static void printArray(Object[] args) {
    		for (Object obj : args)
    			System.out.print(obj + " ");
    		System.out.println();
    	}
    
    	public static void main(String[] args) {
    		printArray(new Object[] { new Integer(47), new Float(3.14), new Double(11.11) });
    		printArray(new Object[] { "one", "two", "three" });
    		printArray(new Object[] { new A(), new A(), new A() });
    	}
    }
output：    
    
    47 3.14 11.11 
    one two three 
    A@15db9742 A@6d06d69c A@7852e922 

You can see that print( ) takes an array of Object, then steps through the array using the foreach syntax and prints each one. The standard Java library classes produce sensible output, but the objects of the classes created here print the class name, followed by an ‘@’ sign and hexadecimal digits. Thus, the default behavior (if you don’t define a toString( ) method for your class, which will be described later in the book) is to print the class name and the address of the object.  

You may see **pre-Java SE5 code** written like the above in order to produce variable argument lists. In Java SE5, however, this long-requested feature was finally added, so you can now use ellipses to define a variable argument list, as you can see in printArray( ):

    
    
    class A {
    }
    
    public class NewVarArgs {
    	static void printArray(Object... args) {
    		for (Object obj : args)
    			System.out.print(obj + " ");
    		System.out.println();
    	}
    
    	public static void main(String[] args) {
    		// Can take individual elements:
    		printArray(new Integer(47), new Float(3.14), new Double(11.11));
    		printArray(47, 3.14F, 11.11);
    		printArray("one", "two", "three");
    		printArray(new A(), new A(), new A());
    		// Or an array:
    		printArray((Object[]) new Integer[] { 1, 2, 3, 4 });
    		printArray(); // Empty list is OK
    	}
    } 
output：

    47 3.14 11.11 
    47 3.14 11.11 
    one two three 
    A@15db9742 A@6d06d69c A@7852e922 
    1 2 3 4 

With varargs, you no longer have to explicitly write out the array syntax—the compiler will actually fill it in for you when you specify varargs. You’re still getting an array, which is why print( ) is able to use foreach to iterate through the array. However, it’s more than just an automatic conversion from a list of elements to an array. Notice the second-t0-last line in the program, where an array of Integer (created using autoboxing) is cast to an Object array (to remove a compiler warning) and passed to printArray( ). Clearly, the compiler sees that this is already an array and performs no conversion on it. So if you have a group of items you can pass them in as a list, and if you already have an array it will accept that as the variable argument list.  


The last line of the program shows that it’s possible to pass zero arguments to a vararg list.
This is helpful when you have optional trailing arguments:

    public class OptionalTrailingArguments {
    	static void f(int required, String... trailing) {
    		System.out.print("required: " + required + " ");
    		for (String s : trailing)
    			System.out.print(s + " ");
    		System.out.println();
    	}
    
    	public static void main(String[] args) {
    		f(1, "one");
    		f(2, "two", "three");
    		f(0);
    	}
    }
output：    

    required: 1 one 
    required: 2 two three 
    required: 0 

This also shows how you can use varargs with a specified type other than Object. Here, all the varargs must be String objects. It’s possible to use any type of argument in varargs, including a primitive type. The following example also shows that the vararg list becomes an array, and if there’s nothing in the list it’s an array of size zero:

    public class VarargType {
    	static void f(Character... args) {
    		System.out.print(args.getClass());
    		System.out.println(" length " + args.length);
    	}
    
    	static void g(int... args) {
    		System.out.print(args.getClass());
    		System.out.println(" length " + args.length);
    	}
    	public static void main(String[] args) {
    		f('a');
    		f();
    		g(1);
    		g();
    		System.out.println("int[]: " + new int[0].getClass());
    	}
    }
output：

    class [Ljava.lang.Character; length 1
    class [Ljava.lang.Character; length 0
    class [I length 1
    class [I length 0
    int[]: class [I

The getClass( ) method is part of Object, and will be explored fully in the Type
Information chapter. It produces the class of an object, and when you print this class, you see an encoded string representing the class type. The leading ‘[‘ indicates that this is an array of the type that follows. The ‘I’ is for a primitive int; to double-check, I created an array of int in the last line and printed its type. This verifies that using varargs does not depend on autoboxing, but that it actually uses the primitive types.  

Varargs do work in harmony with autoboxing, however. For example:
    
    public class AutoboxingVarargs {
    	public static void f(Integer... args) {
    		for (Integer i : args)
    			System.out.print(i + " ");
    		System.out.println();
    	}
    
    	public static void main(String[] args) {
    		f(new Integer(1), new Integer(2));
    		f(4, 5, 6, 7, 8, 9);
    		f(10, new Integer(11), 12);
    	}
    }

output：
    
    1 2 
    4 5 6 7 8 9 
    10 11 12 
    
Notice that you can mix the types together in a single argument list, and autoboxing selectively promotes the int arguments to Integer.  

Varargs complicate the process of overloading, although it seems safe enough at first:

    public class OverloadingVarargs {
    	static void f(Character... args) {
    		System.out.print("first");
    		for (Character c : args)
    			System.out.print(" " + c);
    		System.out.println();
    	}
    
    	static void f(Integer... args) {
    		System.out.print("second");
    		for (Integer i : args)
    			System.out.print(" " + i);
    		System.out.println();
    	}
    
    	static void f(Long... args) {
    		System.out.println("third");
    	}
    
    	public static void main(String[] args) {
    		f('a', 'b', 'c');
    		f(1);
    		f(2, 1);
    		f(0);
    		f(0L);
    		// ! f(); // Won’t compile -- ambiguous
    	}
    }
output：

    first a b c
    second 1
    second 2 1
    second 0
    third
    
In each case, the compiler is using autoboxing to match the overloaded method, and it calls the most specifically matching method.

But when you call f( ) without arguments, it has no way of knowing which one to call.

Although this error is understandable, it will probably surprise the client programmer.

You might try solving the problem by adding a non-vararg argument to one of the methods:

    public class OverloadingVarargs2 {
    	static void f(float i, Character... args) {
    		System.out.println("first");
    	}
    
    	static void f(Character... args) {
    		System.out.print("second");
    	}
    
    	public static void main(String[] args) {
    		f(1, 'a');
    		f('a', 'b');
    	}
    }//会报错

The {CompileTimeError} comment tag excludes the file from this book’s Ant build. If you compile it by hand you’ll see the error message:

> reference to f is ambiguous, both method f(float,java.lang.Character...) in
> OverloadingVarargs2 and method f(java.lang.Character...) in OverloadingVarargs2
> match

If you give both methods a non-vararg argument, it works:
    
    public class OverloadingVarargs3 {
    	static void f(float i, Character... args) {
    		System.out.println("first");
    	}
    
    	static void f(char c, Character... args) {
    
    		System.out.println("second");
    	}
    
    	public static void main(String[] args) {
    		f(1, 'a');
    		f('a', 'b');
    	}
    }

output：

    first
    second

You should generally only use a variable argument list on one version of an overloaded method. Or consider not doing it at all.







