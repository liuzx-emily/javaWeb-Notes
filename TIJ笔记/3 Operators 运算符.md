# 3.1.2 对象赋值 别名
是用等号运算符（=）进行的。它的意思是“取得右边的值，把它复制到左边”。  

   - 对**主数据类型**的赋值是非常直接的。由于主类型容纳了**实际的值**，而不是一个指向对象的句柄，所以在为其赋值的时候，可将来自一个地方的内容复制到另一个地方。例如，假设为主类型使用“A=B”，那么 B处的内容就复制到A。若接着又修改了 A，那么 B 根本不会受这种修改的影响。
   
   - 但在为**对象**“赋值”的时候，情况却不同。对一个对象进行操作时，我们真正操作的是它的**句柄**。所以倘若“从一个对象到另一个对象”赋值，实际就是将句柄从一个地方复制到另一个地方。这意味着假若为对象使用“C=D”，那么C和D最终都会指向同一个对象。

代码：

    package Assignment;
    class Number {
    	int i;
    }
    public class Assignment {
    	public static void main(String[] args) {
    		Number n1 = new Number();
    		Number n2 = new Number();
    		n1.i = 11;
    		n2.i = 22;
    		System.out.println("1: n1.i: " + n1.i +", n2.i: " + n2.i);
    		n1 = n2;
    		System.out.println("2: n1.i: " + n1.i +", n2.i: " + n2.i);
    		n1.i = 33;
    		System.out.println("3: n1.i: " + n1.i +", n2.i: " + n2.i);
    	}
    }

输出结果：
    
    1: n1.i: 11, n2.i: 22
    2: n1.i: 22, n2.i: 22
    3: n1.i: 33, n2.i: 33

看来改变n1的同时也改变了n2！这是由于无论n1还是n2都包含了相同的句柄，它指向相同的对象。  

而在赋值过程中，最初n1中的句柄（该句柄指向一个对象，这个对象的值是11）实际已经丢失；它的对象会由“垃圾收集器”自动清除）  

这种特殊的现象通常也叫作“别名”，是Java 操作对象的一种基本方式。

---
代码：

    package passObject;

    class Letter {
    	char c;
    }
    public class PassObject {
    	static void f(Letter y) {
    			y.c = 'z';
    	}
    	public static void main(String[] args) {
    		Letter x = new Letter();
    		x.c = 'a';
    		System.out.println("1: x.c: " + x.c);
    		f(x);
    	System.out.println("2: x.c: " + x.c);
    	}
    }
输出：

    1: x.c: a
    2: x.c: z

----------
# 3.1.3 运算符
 
- 副作用side effect  
    所有运算符都能根据自己的运算对象生成一个值。除此以外，一个运算符可改变运算对象的值,这就叫副作用。  

- 几乎所有运算符都只能操作“主类型”（Primitives）。  
    唯一的例外是“=”、“==”和“!=”，它们能操作所有对象（也是对象易令人混淆的一个地方）。  
    除此以外，String 类支持“+”和“+=”。


----------
# 3.1.4 递增运算符 ++i, i++

    i : 1
    ++i : 2		//i先自+1：i变为1+1=2；在返回自加后的i：返回2
    i++ : 2		//先返回i的值，返回2；再把i自加：i变为2+1=3
    i : 3
    --i : 2		//i先自减1：i变为3-1=2；在返回自减后的i：返回2
    i-- : 2		//先返回i的值：返回2；再把i自减：i变为2-1=1
    i : 1

----------
# 3.1.5 ==和equals()
	"=="和equals方法究竟有什么区别？


==操作符专门用来比较两个变量的值是否相等，也就是用于比较变量所对应的内存中所存储的数值是否相同，要比较两个基本类型的数据或两个引用变量是否相等，只能用==操作符。

如果一个变量指向的数据是对象类型的，那么，这时候涉及了两块内存，对象本身占用一块内存（堆内存），变量也占用一块内存，例如Objet obj = new Object();变量obj是一个内存，new Object()是另一个内存，此时，变量obj所对应的内存中存储的数值，就是对象占用的那块内存的首地址。对于指向对象类型的变量，如果要比较两个变量是否指向同一个对象，即要看这两个变量所对应的内存中的数值是否相等，这时候就需要用==操作符进行比较。

equals方法是用于比较两个独立对象的内容是否相同，就好比去比较两个人的长相是否相同，它比较的两个对象是独立的。例如，对于下面的代码：

String a=new String("foo");

String b=new String("foo");

两条new语句创建了两个对象，然后用a/b这两个变量分别指向了其中一个对象，这是两个不同的对象，它们的首地址是不同的，即a和b中存储的数值是不相同的，所以，表达式a==b将返回false，而这两个对象中的内容是相同的，所以，表达式a.equals(b)将返回true。

在实际开发中，我们经常要比较传递进行来的字符串内容是否等，例如，String input = …;input.equals(“quit”)，许多人稍不注意就使用==进行比较了，这是错误的，随便从网上找几个项目实战的教学视频看看，里面就有大量这样的错误。记住，字符串的比较基本上都是使用equals方法。


如果一个类没有自己定义equals方法，那么它将继承Object类的equals方法，Object类的equals方法的实现代码如下：

	boolean equals(Object o){
		return this==o;
	}

这说明，**如果一个类没有自己定义equals方法，它默认的equals方法（从Object类继承的）就是使用==操作符，也是在比较两个变量指向的对象是否是同一对象，这时候使用equals和使用==会得到同样的结果**，如果比较的是两个独立的对象则总返回false。如果你编写的类希望能够比较该类创建的两个实例对象的内容是否相同，那么你必须覆盖equals方法，由你自己写代码来决定在什么情况即可认为两个对象的内容是相同的。

----------
# 3.1.8 移位


1. 左移位（**<<**）：在二进制的低位补0。  
 
1. 有符号右移位（**>>**）：如果被操作数的符号为正，则在二进制的高位补0；如果为负，则在二进制的高位补1。
   
1. 无符号右移位（**>>>**）：无论被操作数的符号是正是负，都在二进制位的高位补0。  
 
注意，不存在“无符号左移位（<<<）”一说。



在Think in Java中有这么一段话    

> “对char，byte或者short进行移位处理，那么在移位进行之前，它们会自动转换成一个int。   
> 只有右侧的5个低位才会有用。这样可防止我们在一个int数里移动不切实际的位数。
> 若对一个long值进行处理，最后得到的结果也是long。
> 此时只会用到右侧的6个低位，防止移动超过long值里现成的位数。”

 

对上面那段话的理解是：移位操作符操作的运算对象是二进制的“位”，int类型是32位也就是2的5次幂 ！如果移32位以上，那么原来的数的信息会全部丢失，这样也就没有什么意义了！所以上面的“只有右侧的5个低位才会有用”说的是：移位操作符右端的那个数（化成二进制）的低5位才有用，即
X < <y;
是指y的低5位才有用，即y不能大于32。 而对于long型也是同样的道理！

因此，如果对一个int 型，进行移位，X < <y; 当y小于32时，移位后的结果一般都在我们的预料当中；而如果y大于32时，由于移位超出了int所能表示的范围，这时就先把y化成二进制数，然后取该二进制数右端的低5位，再把这5位化成十进制，此时的这个十进制就是要对X移动的位数。

例如：  
      
    int a=150;   
    System.out.println(Integer.toBinaryString(a));
    System.out.println(Integer.toBinaryString(a << 34));

上面那两个语句的执行过程是：先把a化成二进制数：10010110

执行语句 a << 34：因为34大于32，先把 34化成二进制：100010，取右5位，即00010，化成十进制为2，所以实际上是对a左移两位。输出结果是：1001011000

	题目：请用最有效率的方法计算出7乘以8等于几？

这里所谓的最有效率，实际上就是通过最少、最简单的运算得出想要的结果，而移位是计算机中相当基础的运算了，用它来实现准没错了。左移位“<<”把被操作数每向左移动一位，效果等同于将被操作数乘以2，而8=2^3，就是把2向左移位3次。因此最有效率的计算2乘以8的方法就是“7<<3”。

【最高位代表正负号：0 为正，1 为负。】

-----

# 3.1.11 字串运算符+
+可以连接不同的字串  
【java不可以重载运算符，+的这一功能不是重载，是语法糖】


    //: BitManipulation.java
    
    public class BitManipulation {
    	public static void main(String[] args) {
    		int x = 3, y = 1, z = 2;
    		String sString="a,b,c";
    		//下面一行输出：a,b,c312
    		System.out.println(sString + x + y + z);
    		//下面一行输出：6a,b,c
    		System.out.println(x + y + z+sString );
    	}
    } /// :~

---
# 3.1.12 运算符常规操作规则 #

在C 和C++中，一个特别常见的错误如下：

    while(x = y) {
    	//...
    }
程序的意图是测试是否“相等”，而不是赋值。在 C 和C++中，错误不会在编译时被发现。

在 Java 里，这个表达式的结果并不是布尔值，而编译器期望的是一个布尔值，而且不会从一个int数值中转换得来。所以在编译时，系统就会提示出现错误，有效地阻止我们进一步运行程序。所以这个错误在Java 里永远不会造成更严重的后果。  
唯一不会得到编译错误的时候是x 和y 都为布尔值。在这种情况下，x = y 属于合法表达式。

在C和C++里，类似的一个问题是使用按位AND和OR，而不是逻辑AND和OR。按位AND和OR使用&或|，而逻辑AND和OR使用&&或||。  
在Java里，编译器同样可防止这一点，因为它不允许我们强行使用一种并不属于的类型。

---
# 3.1.13 造型运算符   
在适当的时候，Java 会将一种数据类型自动转换成另一种。例如，假设我们为浮点变量分配一个整数值，计算机会将 int自动转换成 float。  
通过造型，我们可明确设置这种类型的转换，或者在不能转换候时强制进行。  

    void casts() {
    	int i = 200;
    	long l = (long)i;
    	long l2 = (long)200;
    }

正如上例：既可对一个数值进行cast，也可对一个变量进行。  
但在上例的两种情况下，造型均是多余的，因为编译器在必要的时候会自动进行int值到long值的转换。当然，仍然可以设置一个造型，提醒自己留意，也使程序更清楚。  

在C和C++中，造型有时会让人头痛。在Java里，造型则是一种比较安全的操作。
但是，若进行“缩小转换”（Narrowing Conversion），就可能丢失信息。此时，编译器会强迫我们进行造型，就好象说：“这是一件危险的事情——如果您想让我不顾一切地做，那么对不起，请明确造型。”
  
而对于“放大转换”（Widening conversion），则不必进行明确造型，因为新类型肯定能容纳原来类型的信息，不会造成任何信息的丢失。  

Java 允许我们将任何主类型“造型”为其他任何一种主类型，但布尔值（bollean）要除外，后者根本不允许进行任何造型处理。  

“类”不允许进行造型。为了将一种类转换成另一种，必须采用特殊的方法（字串是一种特殊的情况，本书后面会讲到将对象造型到一个类型“家族”里；例如，“橡树”可造型为“树”；反
之亦然。但对于其他外来类型，如“岩石”，则不能造型为“树”）。  

### 1. 字面值 prefix：前缀->进制
##### 十六进制（Base 16） ：
> 适用于所有整数数据类型——前置0x或 0X，后面跟随0-9以及a-f（大小写均可）。若试图将一个变量初始化成超出自身能力的一个值，编译器就会向我们报告一条出错消息。注意在上述代码中，最大的十六进制值只会在char，byte 以及short 身上出现。若超出这一限制，编译器会将值自动变成一个int，并告诉我们需要对这一次赋值进行“缩小造型”。这样一来，我们就可清楚获知自己已超载了边界。  

##### 八进制（Base 8）：  
> 前置0，后跟0-7。  

##### 二进制（Base 2）：
> 在 C，C++或者Java 中，对二进制数字没有相应的“字面”表示方法。
### 2.字面值 suffix：后缀->类型
> long：	大写或小写的 L  
> float：	大写或小写的F  
> double：	大写或小写的D

指数总是采用一种我们认为很不直观的记号方法：1.39e-47f。  
在科学与工程学领域，“e”代表自然对数的基数，约等于2.718。但在java中看到，它真正的含义是
“1.39×10 的-47次方”。  

注意：如果编译器能够正确地识别类型，就不必使用尾随字符。对于下述语句：

    long n3 = 200L;

它并不存在含混不清的地方，所以 200后面的一个 L大可省去。  
然而，对于下述语句：

    float f4 = 1e-47f; //10 的幂数

编译器通常会将指数作为双精度数（double）处理，所以假如没有这个尾随的 f，就会收到一条出错提示，告诉我们须用一个“造型”将double 转换成 float。

假若对主数据类型执行任何算术或按位运算，只要它们“比int小”（即 char，byte 或者short），那么在正式执行运算之前，那些值会自动转换成int。这样一来，最终生成的值就是int类型。所
以只要把一个值赋回较小的类型，就必须使用“造型”。  
此外，由于是将值赋回给较小的类型，所以可能出现信息丢失的情况）。

---
# 3.1.14 Java 没有“sizeof ” #
在C 和C++中，sizeof()运算符能满足我们的一项特殊需要：获知为数据项目分配的字符数量。  
在C 和C++中，sizeof()最常见的一种应用就是“移植”。不同的数据在不同的机器上可能有不同的大小，所以在进行一些对大小敏感的运算时，程序员必须对那些类型有多大做到心中有数。例如，一台计算机可用32位来保存整数，而另一台只用16 位保存。显然，在第一台机器中，程序可保存更大的值。正如您可能已经想到的那样，移植是令C 和C++程序员颇为头痛的一个问题。

Java 不需要sizeof()运算符来满足这方面的需要，因为所有数据类型在所有机器的大小都是相同的。我们不必考虑移植问题——Java 本身就是一种“与平台无关”的语言。

---
# 3.1.15 运算符优先顺序 助记 #

“Ulcer Addicts Really Like C A lot”，即“溃疡患者特别喜欢（维生素）C”。

    助记词			运算符类型				  运算符
    Ulcer 			Unary 					(+, -, ++, --, !)
    Addicts 		Arithmetic(shift)）		(+, -, *, /, %, <<, >>)
    Really 			Relational 				(<, >, ==, <=, >=, !=)
    Like 			Logical(bitwise) 		(&&, ||, &, |, ^)
    C 				Conditional				( ? :)
    A Lot 			Assignment 				(=，+=,-=,....)


 当然，对于移位和按位运算符，上表并不是完美的助记方法；但对于其他运算来说，它确实很管用。

---
# 3.1.16 运算符总结


- 布尔值（boolean）的能力非常有限。  
我们只能为其赋予true 和false 值。而且可测试它为真还是为假

- 在char，byte 和 short中，我们可看到算术运算符的“转型”效果。对这些类型的任何一个进行算术运算，
都会获得一个int结果。必须将其明确“造型”回原来的类型（缩小转换会造成信息的丢失），以便将值赋回那个类型。

- 但对于int值，却不必进行造型处理，因为所有数据都已经属于 int类型。然而，不要放松警惕，认为一切事情都是安全的。如果对两个足够大的int 值执行乘法运算，结果值就会溢出。


		//: Overflow.java
		// Surprise! Java lets you overflow.
		public class Overflow {
			public static void main(String[] args) {
				int big = 0x7fffffff; // max int value
				prt("big = " + big);
				int bigger = big * 4;
				prt("bigger = " + bigger);
			}
	
			static void prt(String s) {
				System.out.println(s);
			}
    	} ///:~	
输出结果如下：

	    big = 2147483647
	    bigger = -4
而且不会从编译器那里收到出错提示，运行时也不会出现异常反应。Java确实是很好的东西，但却没有“那么”好！  

- 对于char，byte 或者short，混合赋值并不需要造型。即使它们执行转型操作，也会获得与直接算术运算相同的结果。而在另一方面，将造型略去可使代码显得更加简练。

- 除boolean 以外，任何一种主类型都可通过造型变为其他主类型。同样地，当造型成一种较小的类型时，必须留意“缩小转换”的后果。否则会在造型过程中不知不觉地丢失信息。

- Java不允许将一个数字作为布尔值使用：

		int a=1;
	    if(a){	//错误
	    	...
	    }
	    if(a！=0){	// 正确
	    	...
    	}

