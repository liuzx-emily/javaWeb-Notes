匿名内部类：也就是**没有名字的内部类**

正因为没有名字，所以匿名内部类只能使用一次，它通常用来**简化代码编写**

但使用匿名内部类还有个前提条件：**必须继承一个父类或实现一个接口**
[
http://www.cnblogs.com/nerxious/archive/2013/01/25/2876489.html](http://www.cnblogs.com/nerxious/archive/2013/01/25/2876489.html)

[http://blog.csdn.net/chenssy/article/details/13170015](http://blog.csdn.net/chenssy/article/details/13170015)

	package lzx;
    
    import static abc.Print.*;
    
    interface Contents {
    	public void value();
    }
    
    public class Parcel7 {
    	public Contents getcontents(int num) {
    		return new Contents() { // Insert a class definition
    			private int i = num;
    			public void value() {
    				i+=5;
    				print(i);
    			}
    		}; // Semicolon required in this case
    	}
    
    	public static void main(String[] args) {
    		Parcel7 p = new Parcel7();
    		Contents c = p.getcontents(16);
    		c.value();
    	}
    }

The contents( ) method combines the creation of the return value with the definition of the
class that represents that return value! In addition, the class is anonymous; it has no name.
To make matters a bit worse, it looks like you’re starting out to create a Contents object, But
then, before you get to the semicolon, you say, "But wait, I think I’ll slip in a class definition."  

What this strange syntax means is "Create an object of an anonymous class that’s inherited
from Contents." The reference returned by the new expression is automatically upcast to a
Contents reference.

---
基类的constructor有参数： 
   
    package lzx;
    
    import static abc.Print.*;
    
    class Wrapping {
    	private int i;
    
    	public Wrapping(int x) {
    		i = x;
    	}
    
    	public int getvalue() {
    		return i;
    	}
    }
    
    public class Parcel8 {
    	public Wrapping wrapping(int x) {
    		// Base constructor call:
    		return new Wrapping(x) { // Pass constructor argument.
    			public int getvalue() {
    				return super.getvalue() * 47;
    			}
    		}; // Semicolon required
    	}
    
    	public static void main(String[] args) {
    		Parcel8 p = new Parcel8();
    		Wrapping w = p.wrapping(10);
    		print(w.getvalue());
    	}
    }
    





