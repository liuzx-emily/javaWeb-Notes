# 纯粹的面向对象程序设计方法

1. ##### 所有东西都是对象  
可将对象想象成一种新型变量；它保存着数据，但可要求它对自身进行操作。理论上讲，可从要解决的问题身上提出所有概念性的组件，然后在程序中将其表达为一个对象。  

1. ##### 程序是很多对象的组合
通过消息传递，各对象知道自己该做些什么。为了向对象发出请求，需向那个对象“发送一条消息”。更具体地讲，可将消息想象为一个调用请求，它调用的是从属于目标对象的一个子例程或函数。  

1. ##### 每个对象都有自己的存储空间，可容纳其他对象。
或者说，通过封装现有对象，可制作出新型对象。所以，尽管对象的概念非常简单，但在程序中却可达到任意高的复杂程度。  

1. ##### 每个对象都有一种类型。
根据语法，每个对象都是某个“类”的一个“实例”。其中，“类”（Class）是“类型”（Type）的同义词。一个类最重要的特征就是“能将什么消息发给它？”。  

1. ##### 同一类所有对象都能接收相同的消息。
这实际是别有含义的一种说法，大家不久便能理解。由于类型为“圆”（Circle）的一个对象也属于类型为“形状”（Shape）的一个对象，所以一个圆完全能接收形状消息。这意味着可让程序代码统一指挥“形状”，令其自动控制所有符合“形状”描述的对象，其中自然包括“圆”。这一特性称为对象的“**可替换性**”，是OOP最重要的概念之一。  

---

# 1.4 方案的重复使用 组织 


需要经验以及洞察力，才能设计出一个好的方案，才有可能重复使用。  
  
为重复使用一个类，可以将那个类的一个对象置入一个新类。我们把这叫作“**创建一个成员对象**”。新类可由任意数量和类型的其他对象构成。这个概念叫作“**组织**”——在现有类的基础上组织一个新类。有时，我们也将组织称作“包含”关系，比如“一辆车包含了一个变速箱”。   

对象的组织具有极大的灵活性。新类的“成员对象”通常设为Private，使用这个类的客户程序员不能访问它们。这样一来，我们可在不干扰客户代码的前提下，从容地修改那些成员。也可以在“运行期”更改成员，这进一步增大了灵活性。后面要讲到的“**继承”并不具备这种灵活性**，因为编译器必须对通过继承创建的类加以限制。

由于继承的重要性，所以在面向对象的程序设计中，它经常被重点强调。作为新加入这一领域的程序员，或许早已先入为主地认为“继承应当随处可见”。沿这种思路产生的设计将是非常笨拙的，会大大增加程序的复杂程度。相反，**新建**类的时候，首先应考虑“**组织**”对象；这样做显得更加简单和灵活。利用对象的组织，我们的设计可保持清爽。一旦需要用到继承，就会明显意识到这一点。

---
# 1.5 继承：重新使用接口  
在Java 语言中，继承是通过 **extends**关键字实现的  

使用继承时，相当于创建了一个新类。这个新类不仅包含了现有类型的所有成员（尽管private 成员被隐藏起来，且不能访问），但更重要的是，它复制了基础类的接口。也就是说，可向基础类的对象发送的所有消息亦可原样发给衍生类的对象。这意味着**衍生类具有与基础类相同的类型**！为真正理解面向对象程序设计的含义，首先必须认识到这种类型的等价关系。    

由于**基础类和衍生类具有相同的接口**，所以那个接口必须进行特殊的设计。也就是说，对象接收到一条特定的消息后，必须有一个“方法”能够执行。若只是简单地继承一个类，并不做其他任何事情，来自基础类接口的方法就会直接照搬到衍生类。这意味着衍生类的对象不仅有相同的类型，也有同样的行为，这通常是我们不愿见到的。  

- 改写原函数【等价】
- 创建新函数【类似】

---
# 1.6 多形对象的互换使用
#### 1.6.1动态绑定

我们将这种把衍生类型当作它的基本类型处理的过程叫“Upcasting”（上溯造型）。其中，“cast”（造型）是指根据一个现成的模型创建；而“Up”（向上）表明继承的方向是从“上面”来的——即基础类位于顶部，而衍生类在下方展开。所以，根据基础类进行造型就是一个从上面继承的过程，即“Upcasting”。  
将一条消息发给对象时，如果并不知道对方的具体类型是什么，但采取的行动同样是正确的，这种情况就叫作“**多形性**”（**Polymorphism**）。对面向对象的程序设计语言来说，它们用以实现多形性的方法叫作“**动态绑定**”。  

有些语言要求我们用一个特殊的关键字来允许动态绑定。在C++中，这个关键字是 virtual。在Java 中，我们则完全不必记住添加一个关键字，因为函数的动态绑定是自动进行的。所以在将一条消息发给对象时，我们完全可以肯定对象会采取正确的行动，即使其中涉及上溯造型之类的处理。
#### 1.6.2 abstract

1. 设计程序时，我们经常都希望基础类只为自己的衍生类提供一个接口。也就是说，我们不想其他任何人实际创建基础类的一个对象，只对上溯造型成它，以便使用它们的接口。为达到这个目的，需要把那个类变成“抽象”的——使用**abstract**关键字。若有人试图创建抽象类的一个对象，编译器就会阻止他们。这种工具可有效强制实行一种特殊的设计。 
 
1. 亦可用abstract 关键字描述一个尚未实现的方法——作为一个“根”使用，指出：“这是适用于从这个类继承的所有类型的一个接口函数，但目前尚没有对它进行任何形式的实现。”抽象方法也许只能在一个抽象类里创建。继承了一个类后，那个方法就必须实现，否则继承的类也会变成“抽象”类。通过创建一个抽象方法，我们可以将一个方法置入接口中，不必再为那个方法提供可能毫无意义的主体代码。  
interface（接口）关键字将抽象类的概念更延伸了一步，它完全禁止了所有的函数定义。“接口”是一种相当有效和常用的工具。另外如果自己愿意，亦可将多个接口都合并到一起（不能从多个普通class 或abstract class 中继承）。

---
# 1.7.2单根结构
所有类最终是否都应从单独一个基础类继承？  
在Java 中（与其他几乎所有OOP语言一样），对这个问题的答案都是**肯定**的，而且这个终级基础类的名字很简单，就是一个“Object”。  
这种“单根结构”具有许多方面的优点。  


- 单根结构中的所有对象都有一个**通用接口**，所以它们最终都属于**相同的类型**。
> 另一种方案（就象 C++那样）是我们不能保证所有东西都属于相同的基本类型。

- 单根结构中的所有对象（比如所有 Java 对象）都可以保证拥有一些特定的功能。在自己的系统中，我们知道对每个对象都能进行一些基本操作。一个单根结构，加上所有对象都在内存堆中创建，可以**极大简化参数的传递**（这在 C++里是一个复杂的概念）。

- 利用单根结构，我们可以**更方便地实现一个垃圾收集器**。与此有关的必要支持可安装于基础类中，而垃圾收集器可将适当的消息发给系统内的任何对象。  
如果没有这种单根结构，而且系统通过一个句柄来操纵对象，那么实现垃圾收集器的途径会有很大的不同，而且会面临许多障碍。


- 由于运行期的类型信息肯定存在于所有对象中，所以永远不会遇到判断不出一个对象的类型的情况。这对系统级的操作来说显得特别重要，比如违例控制；而且也能在程序设计时获得更大的灵活性。

> 为什么C++没有采用单根结构呢？  
> 事实上，这是早期在效率与控制上权衡的一种结果。单根结构会给程序设计带来一些限制。  
> And more importantly，它使新程序与原有C代码更难兼容。  
> 尽管这些限制仅在特定的场合会真的造成问题，但为了获得最大的灵活程度，C++最终决定放弃采用单根结构这一做法。

---
# 1.7 对象的创建、存在时间

### 问题：
	1. 对象的创建及破坏方式？
	2. 对象需要的数据位于哪儿？
	3. 如何控制对象的“存在时间”？  
 
#### C++等 
认为程序的执行效率是最重要的，所以它允许程序员作出选择。为获得最快的运行速度，存储以及存在时间可在编写程序时决定，只需将对象放置在堆栈（有时也叫作自动或定域变量）或者静态存储区域即可。这样便为存储空间的分配和释放提供了一个优先级。  
某些情况下，这种优先级的控制是非常有价值的。然而，我们同时也牺牲了灵活性，因为在编写程序时，必须知道对象的准确的数量、存在时间、以及类型。如果要解决的是一个较常规的问题，如计算机辅助设计、仓储管理或者空中交通控制，这一方法就显得太局限了。
#### java等
在一个内存池中动态创建对象，该内存池亦叫“堆”或者“内存堆”。若采用这种方式，除非进入运行期，否则根本不知道到底需要多少个对象，也不知道它们的存在时间有多长，以及准确的类型是什
么。这些参数都在程序正式运行时才决定的。若需一个新对象，只需在需要它的时候在内存堆里简单地创建它即可。由于存储空间的管理是运行期间动态进行的，所以在内存堆里分配存储空间的时间比在堆栈里创建的时间长得多（在堆栈里创建存储空间一般只需要一个简单的指令，将堆栈指针向下或向下移动即可）。由于动态创建方法使对象本来就倾向于复杂，所以查找存储空间以及释放它所需的额外开销不会为对象的创建造成明显的影响。除此以外，更大的灵活性对于常规编程问题的解决是至关重要的。 

  
若在堆栈或者静态存储空间里创建一个对象，编译器会判断对象的持续时间有多长，到时会自动“破坏”或者“清除”它。  
程序员可用两种方法来破坏一个对象：用程序化的方式决定何时破坏对象，或者利用由运行环境提供的一种“垃圾收集器”特性，自动寻找那些不再使用的对象，并将其清除。当然，垃圾收集器显得方便得多，但要求所有应用程序都必须容忍垃圾收集器的存在，并能默许随垃圾收集带来的额外开销。但这并不符合C++语言的设计宗旨，所以未能包括到 C++里。但Java 确实提供了一个垃圾收集器

---
# variable和field的区别

variable
    
> An item of data named by an identifier. Each variable has a type, such as int or Object, and a scope.

instance variable  实例变量
    
> Any item of data that is associated with a particular object. Each instance of a class has its own copy of the instance variables defined in the class. Also called a field. 


class variable  类变量
>  A data item associated with a particular class as a whole--not with particular instances of the class. Class variables are defined in class definitions. Also called a static field. 



local variable 局部变量
>  A data item known within a block, but inaccessible to code outside the block. For example, any variable defined within a method is a local variable and can't be used outside the method. 

field
    
> A data member of a class. Unless specified otherwise, a field is not static.


查询网址：[http://docs.oracle.com/javase/tutorial/information/glossary.html#F](http://docs.oracle.com/javase/tutorial/information/glossary.html#F)  