#Constructor initialization

    //: initialization/Counter.java
    public class Counter {
		int i;
		Counter() { i = 7; }
    	// ...
    } ///:~

i will first be initialized to 0, then to 7.   

This is true with all the primitive types and with object references, including those that are given explicit initialization at the point of definition.   

For this reason, the compiler doesn’t try to force you to initialize elements in the constructor at any particular place, or before they are used — initialization is already guaranteed.

---






## 1. Order of initialization ##
**Within a class, the order of initialization is determined by the order that the variables are defined within the class.** 
The variable definitions may be scattered throughout and in between method definitions, **but the variables are initialized before any methods can be called — even the constructor.**

For example:


    class Window {
    	Window(int marker) {
    		print("Window(" + marker + ")");
    	}
    }
    
    class House {
    	Window w1 = new Window(1); // Before constructor
    
    	House() {
    		print("House()");
    		w3 = new Window(33); // Reinitialize w3
    	}
    
    	Window w2 = new Window(2); // After constructor
    
    	void f() {
    		print("f()");
    	}
    
    	Window w3 = new Window(3); // At end
    }
    
    public class OrderOfInitialization {
    	public static void main(String[] args) {
    		House h = new House();
    		h.f(); // Shows that construction is done
    	}
    }

Output:

    Window(1)
    Window(2)
    Window(3)
    House()
    Window(33)
    f()


---
## 2. static data initialization 

There’s only a single piece of storage for a static, regardless of how many objects are created.You can’t apply the static keyword to local variables, so it only applies to fields. If a field is a static primitive and you don’t initialize it, it gets the standard initial value for its type. If it’s a reference to an object, the default initialization value is null.  
 

    class Bowl {
    	Bowl(int marker) {System.out.println("Bowl(" + marker + ")");}    
    	void f1(int marker) {System.out.println("f1(" + marker + ")");}
    }
    
    class Table {
    	static Bowl bowl1 = new Bowl(1);      
    	Table() {
    		System.out.println("Table()");
    		bowl2.f1(1);
    	}    
    	void f2(int marker) {System.out.println("f2(" + marker + ")");}    
    	static Bowl bowl2 = new Bowl(2);
    }
    
    class Cupboard {
    	Bowl bowl3 = new Bowl(3);
    	static Bowl bowl4 = new Bowl(4);    
    	Cupboard() {
    		System.out.println("Cupboard()");
    		bowl4.f1(2);
    	}
    
    	void f3(int marker) {System.out.println("f3(" + marker + ")");}
        static Bowl bowl5 = new Bowl(5);
    }
    
    public class StaticInitialization {
    	public static void main(String[] args) {
    		System.out.println("Creating new Cupboard() in main");
    		new Cupboard();
    		System.out.println("Creating new Cupboard() in main");
    		new Cupboard();
    		table.f2(1);
    		cupboard.f3(1);
    	}    
    	static Table table = new Table();
    	static Cupboard cupboard = new Cupboard();
    }
output：

    Bowl(1)
    Bowl(2)
    Table()
    f1(1)
    Bowl(4)
    Bowl(5)
    Bowl(3)
    Cupboard()
    f1(2)
    Creating new Cupboard() in main
    Bowl(3)
    Cupboard()
    f1(2)
    Creating new Cupboard() in main
    Bowl(3)
    Cupboard()
    f1(2)
    f2(1)
    f3(1)

 
From the output, you can see that the **static initialization occurs only if it’s necessary. If you don’t create a Table object and you never refer to Table.bowl1 or Table.bowl2, the static Bowl bowl1 and bowl2 will never be created.** They are initialized only when the first Table object is created (or the first static access occurs). After that, the static objects are not reinitialized.  

The order of initialization is **statics first**, if they haven’t already been initialized by a previous object creation, and **then the non-static objects**.   

To execute main( ) (a static method), the StaticInitialization class must be
loaded, and its static fields table and cupboard are then initialized, which causes those classes to be loaded, and since they both contain static Bowl objects, Bowl is then loaded. 

Thus, all the classes in this particular program get loaded before main( ) starts. This is usually not the case, because in typical programs you won’t have everything linked together by statics as you do in this example.  

To summarize the process of creating an object, consider a class called Dog:  

1. Even though it doesn’t explicitly use the static keyword, the constructor is actually a static method. So the first time an object of type Dog is created, or the first time a static method or static field of class Dog is accessed, the Java interpreter must locate Dog.class, which it does by searching through the classpath.
2. As Dog.class is loaded (creating a Class object, which you’ll learn about later), all of its static initializers are run. Thus, static initialization takes place only once, as the Class object is loaded for the first time.
3. When you create a new Dog( ), the construction process for a Dog object first
allocates enough storage for a Dog object on the heap.
4. This storage is wiped to zero, automatically setting all the primitives in that Dog object to their default values (zero for numbers and the equivalent for boolean and char) and the references to null.
5. Any initializations that occur at the point of field definition are executed.
6. Constructors are executed. As you shall see in the Reusing Classes chapter, this might actually involve a fair amount of activity, especially when inheritance is involved.

---
## 3. Explicit static initialization

Java allows you to group other static initializations inside a special “static clause”(sometimes called a static block) in a class.
   
It looks like this:

    //: initialization/Spoon.java
    public class Spoon {
    	static int i;
    	static {
    		i = 47;
    	}
    } /// :~
It appears to be a method, but it’s just the static keyword followed by a block of code. This code, like other static initializations, is executed only once: the first time you make an object of that class or the first time you access a static member of that class (even if you never make an object of that class).   

For example:

    
    //: initialization/ExplicitStatic.java
    
    class Cup {
    	Cup(int marker) {
    		System.out.println("Cup(" + marker + ")");
    	}
    
    	void f(int marker) {
    		System.out.println("f(" + marker + ")");
    	}
    }
    
    class Cups {
    	static Cup cup1;
    	static Cup cup2;
    	static {
    		cup1 = new Cup(1);
    		cup2 = new Cup(2);
    	}
    
    	Cups() {
    		System.out.println("Cups()");
    	}
    }
    
    public class ExplicitStatic {
    	public static void main(String[] args) {
    		System.out.println("Inside main()");
    		Cups.cup1.f(99); // (1)
    	}
    	// static Cups cups1 = new Cups(); // (2)
    	// static Cups cups2 = new Cups(); // (2)
    }
output:
    
    Inside main()
    Cup(1)
    Cup(2)
    f(99)

The static initializers for Cups run when either the access of the static object cup1 occurs on the line marked (1), or if line (1) is commented out and the lines marked (2) are uncommented. If both (1) and (2) are commented out, the static initialization for Cups never occurs, as you can see from the output. Also, it doesn’t matter if one or both of the lines marked (2) are uncommented; the static initialization only occurs once.


---
## 4. Non-static instance initialization

Java provides a similar syntax, called instance initialization, for initializing non-static variables for each object.  

Here’s an example:
    
    //: initialization/Mugs.java
    // Java "Instance Initialization."
    
    
    class Mug {
    	Mug(int marker) {
    		System.out.println("Mug(" + marker + ")");
    	}
    
    	void f(int marker) {
    		System.out.println("f(" + marker + ")");
    	}
    }
    
    public class Mugs {
    	Mug mug1;
    	Mug mug2;
    	{
    		mug1 = new Mug(1);
    		mug2 = new Mug(2);
    		System.out.println("mug1 & mug2 initialized");
    	}
    
    	Mugs() {
    		System.out.println("Mugs()");
    	}
    
    	Mugs(int i) {
    		System.out.println("Mugs(int)");
    	}
    
    	public static void main(String[] args) {
    		System.out.println("Inside main()");
    		new Mugs();
    		System.out.println("new Mugs() completed");
    		new Mugs(1);
    		System.out.println("new Mugs(1) completed");
    	}
    }
output：
    
    Inside main()
    Mug(1)
    Mug(2)
    mug1 & mug2 initialized
    Mugs()
    new Mugs() completed
    Mug(1)
    Mug(2)
    mug1 & mug2 initialized
    Mugs(int)
    new Mugs(1) completed

You can see that the instance initialization clause:

    {
     	mug1 = new Mug(1);
   		mug2 = new Mug(2);
    	print("mug1 & mug2 initialized");
    }
looks exactly like the static initialization clause except for the missing static keyword. This syntax is necessary to support the initialization of anonymous inner classes (see the Inner Classes chapter), but it also allows you to guarantee that certain operations occur regardless of which explicit constructor is called. From the output, you can see that the **instance initialization clause is executed before either one of the constructors**.