--------------------------------
数据类型：
	1）基本数据类型：byte、short、int、long、float、double、char、boolean 
	2）引用数据类型: 数组、类、接口。

在 java程序中所有的数据都需要当做对象来处理，针对8种基本数据类型提供了包装类，如下：
	int --> Integer
	byte --> Byte
	short --> Short
	long --> Long
	char --> Character
	double --> Double
	float --> Float
	boolean --> Boolean
包装类是对象，可以是null，可以有属性和方法



--------------------------------
java三大特征：继承 + 封装 + 多态

继承：OOP最显著的特性。好处：
	1：提高了代码的复用性。
	2：让类与类之间产生了关系，提供了另一个特征多态的前提。

封装：隐藏内部实现(private)，对外提供借口

多态：OOP特征之一，函数本身就具备多态性，某一种事物有不同的具体的体现。 
	体现：父类引用或者接口的引用指向了自己的子类对象。//Animal a = new Cat();
	好处：提高了程序的扩展性。
	弊端：当父类引用指向子类对象时，虽然提高了扩展性，但是只能访问父类中具备的方法，不可以访问子类中特有的方法。(前期不能使用后期产生的功能，即访问的局限性)
	前提：
	    1：必须要有关系，比如继承、或者实现。
	    2：通常会有覆盖操作。


--------------------------------
数组：用于存储同一类型数据的一个容器。好处：可以对该容器中的数据进行编号，从0开始。数组用于封装数据，就是一个具体的实体。
如何在java中表现一个数组呢？两种表现形式。
	1） 元素类型[] 变量名 = new 元素类型[元素的个数]；
	2） 元素类型[] 变量名 = {元素1，元素2...}；
		元素类型[] 变量名 = new 元素类型[]{元素1，元素2...}；

集合框架：★★★★★，用于存储数据的容器。
特点：
1：对象封装数据，对象多了也需要存储。集合用于存储对象。
2：对象的个数确定可以使用数组，但是不确定怎么办？可以用集合。因为集合是可变长度的。
 
集合和数组的区别：
1：数组是固定长度的；集合可变长度的。
2：数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存储引用数据类型。
3：数组存储的元素必须是同一个数据类型；集合存储的对象可以是不同数据类型。


Iteraotr
	|--Collection：	
		|--Set：无序，不可重复。
	    |--List：有序，可重复
		    |--ArrayList：底层的数据结构是数组,线程不同步，ArrayList替代了Vector，查询元素的速度非常快。
	|--Map：
		|--HashMap：底层是哈希表数据结构，是线程不同步的。可以存储null键，null值。替代了Hashtable.



-----------------JRE和JDK-----------------
JRE： Java Runtime Environment
	包含了java虚拟机，java基础类库
JDK：Java Development Kit
	包含了JRE，同时还包含了编译java源码的编译器javac，还包含了很多java程序调试和分析的工具：jconsole，jvisualvm等工具软件，还包含了java程序编写所需的文档和demo例子程序。

需要运行java程序，只需安装JRE就可以了。如果要编写java程序，需要安装JDK。



-----------------eclipse和myeclipse-----------------
1 eclipse：免费 开发工具
2 myeclipse：收费 插件



-----------------myeclipse快捷键-----------------
代码提示 		Content Assist 		alt+w（改）
快速导包		Organize Imports 	ctrl+shift+o
快速修复		Quick Fix			ctrl+1
单行注释		Toggle Comment 		ctrl+/
多行注释		Add Block Comment	ctrl+shift+/
取消多行注释						ctrl+shift+\
删除行			Delete Line			ctrl+d
代码格式化		Format				ctrl+shift+f

getter		alt+shit+s打开source，选getter



-----------------单元测试junit-----------------
1 测试内容：类中的方法
2 junit不是javase的一部分，想要使用需要导入jar包。但是，myeclipse中自带了junit的jar包。
  junit有不同的版本：3.x 4.x
3 单元测试写法：
	在项目下新建source folder，和src同级，起名为junittt（随便起）
	在junittt中新建一个包，包名需要和"待测试的方法所在类"的包名一致

	@Test：进行单元测试
	@Ignore：不进行单元测试
	@Before：在每个方法之前运行
	@After：在每个方法之后运行
	
	public class 类名随便起 {
		@Test
		public void 方法名随便起(){
			// 测试内容
		}
	}

4 运行：Run As JUnit Test



-----------------list集合-----------------
list：
	1 ArrayList：最有用的List集合实现。由一个整形数字或数组存储了集合的大小（数组中第一个没有使用的元素）。像所有的List集合一样，ArrayList可以在必要的时候扩展它的大小。ArrayList访问元素的时间开销固定。在尾部添加元素成本低（为常数复杂度），而在头部添加元素成本很高（线性复杂度）。这是由ArrayList的实现原理——所有的元素的从角标为0开始一个接着一个排列造成的。也就是说，从要插入的元素位置往后，每个元素都要向后移动一个位置。
	2 linkedList：每一个节点都保存着上一个节点和下一个节点的指针。这就意味着数据的存取和更新具有线性复杂度（这也是一个最佳化的实现，每次操作都不会遍历数组一半以上，操作成本最高的元素就是数组中间的那个）。
	3 Vector：一个带有线程同步方法的ArrayList版本，现在已经被ArrayList代替了

例子：
	List<String> list = new ArrayList<String>();
	// 添加：add()
	list.add("aaa");
	list.add("bbb");
	// 取：get(index)
	System.out.println(list.get(1));


遍历方法：
	1 普通for
		for(int i=0;i<list.size();i++){
			 String txt=list.get(i);
			 System.out.println(txt);
		}
	2 增强for
		for (String txt : list) {
			System.out.println(txt);
		}
	3 迭代器
		Iterator<String> it=list.iterator();
		while(it.hasNext()){
			String txt=it.next();
			System.out.println(txt);
		}



-----------------set集合-----------------
取出顺序和添加顺序无关；不能有重复
	Set<String> set =new HashSet<String>();
	set.add("aaa");
	set.add("bbb");
	set.add("ccc");
	set.add("ddd");
	set.add("bbb");
	for (String string : set) {
		System.out.print(string+'\t');
	}
	输出结果:
		aaa	ddd	ccc	bbb
遍历方法：
	1 增强for
	2 迭代器
		Iterator<String> it=set.iterator();
		while(it.hasNext()){
			String txt=it.next();
			System.out.print(txt+"\t");
		}



-----------------map集合-----------------
HashMap：最常用的Map实现。只是将一个键和值相对应，并没有其他的功能。

	Map<String,Integer> map = new HashMap<String,Integer>();
	map.put("a",1);
	map.put("b",2);
	map.put("c",3);
	System.out.println(map.get("a"));

遍历方法：
	1 获取所有的key，通过key得到value
		Set<String> keySet=map.keySet();
		for(String key:keySet){
			Integer value=map.get(key);
			System.out.println(value);			
		}
		输出结果：2	3 1	
	2 Entry是Map中用来保存一个键值对的，而Map实际上就是多个Entry的集合。
		Set<Entry<String,Integer>> entrySet=map.entrySet();
		for (Entry<String, Integer> entry : entrySet) {
			String key=entry.getKey();
			Integer value=entry.getValue();
			System.out.println(key+": "+value);
		}
		输出结果：
			b: 2
			c: 3
			a: 1



-----------------jdk-----------------
jdk版本：1.1 1.2 1.3 1.4 5.0
jdk5.0新特性：
	泛型
	枚举
	静态导入
	自动拆装箱
	增强for
	可变参数



-----------------jdk5.0新特性：泛型-----------------
泛型里面不能写基本数据类型，要写对应的包装类
	byte		Byte
	short		Short
	int 		Integer
	long 		Long
	folat 		Float
	double 		Double
	char 		Character
	boolean 	Boolean

1 泛型一般使用在集合上，常用集合：list set map
	为什么要使用泛型？
		新元素放入集合后，失去本身的类型，变成Object类型。
		想取出的时候要进行类型转换，很容易出错。
	
2 在方法中使用泛型
	方法逻辑相同，只是数据类型不同
	<T>写在返回值之前，表示任意类型（可以不是T，随便起）

	public static void main(String[] args) {
		// 泛型里不能是基本类型int，必须是包装类Integer	
		Integer[] arr={10,11,12,13,14,15};
		String[] arr2={"a","b","c","d"};
		swap(arr,1,3);
		swap(arr2,1,3);
		System.out.println(Arrays.toString(arr));
		System.out.println(Arrays.toString(arr2));		
	}
	private static <T> void swap(T[] arr,int i,int j){
		T temp;
		temp=arr[i];
		arr[i]=arr[j];
		arr[j]=temp;
	}

3 在类中使用泛型（不常用，了解即可）
	public class Test<T>{
		T num;

		void func(T sum){}

		// static的不能用泛型，下面两行都会报错
		// static T num2;
		// static void func2(T sum){}

		// 下面的不报错：
		static <T2> void fun3(T2 sum){}

	}

4 泛型擦除
	泛型只存在于源代码中，编译后就不存在了

-----------------jdk5.0新特性：枚举-----------------
需要在一定的范围内取值（红绿灯）

枚举是一种特殊的类。
枚举类中声明的每一个枚举值，都是枚举类的一个实例对象。
与java中的普通类一样，在声明枚举类时，也可以声明属性、方法和构造函数，但构造函数必须是private的。
枚举类可以实现接口、继承抽象类。
jdk5中扩展了switch语句，它除了可以接受int byte char short之外，还可以接收一个枚举类型。

	public class MeiJu {
		public static void main(String[] args) {		
			Color color=Color.GREEN;
		}
	}
	enum Color{
		RED,GREEN,YELLOW;
	}
	class Color2{
		public static final Color2 RED=new Color2();
		public static final Color2 GREEN=new Color2();
		public static final Color2 YELLOW=new Color2();
	}
	(枚举类Color是Color2的简写形式)	
	------------------------------
	public class MeiJu {
		public static void main(String[] args) {		
			Color color=Color.GREEN;
			color.show();
		}
	}
	enum Color{
		RED("red",1),GREEN("green",2),YELLOW("yellow",3);
		private String name;
		private Integer level;
		private Color(String name,Integer level){
			this.name=name;
			this.level=level;
		}
		public void show(){
			System.out.println("颜色："+this.name+"；重要级别："+this.level);
		}
	}

常用方法：
	color.name()：返回枚举的名称
	color.ordinal()：返回枚举的下标（从0开始）

还有两个方法不在API里面，但是编译的时候会生成：
	Color.valueof(String name)：返回枚举对象
	Color.values()：返回所有枚举对象数组

练习：枚举对象、枚举对象下标、枚举对象名称之间的转换



-----------------jdk5.0新特性：静态导入-----------------
了解即可，不常用。容易出错

可以在代码里面，直接导入静态方法或常量

	import static java.lang.System.out;
	import static java.lang.Math.abs;

	public class staticImport {
		public static void main(String[] args) {
			double num=abs(-2.9);
			out.println(num);			
		}
	}



-----------------jdk5.0新特性：自动拆装箱-----------------
基本类型 <----> 包装类 自动转换

	Integer i=10;	// 自动装箱
	int j=i;		// 自动拆箱

jdk1.4-中不能自动转换，上面的写法会报错，需要：
	Integer i=new Integer(10);
	int j=i.intValue();
jdk是向下兼容的，所以在jdk1.5+中上面两行可以运行	

	public static void main(String[] args) {
		doo(1);		
	}
	private static void doo(double d){
		System.out.println("double");
	}

	private static void doo(Integer i){
		System.out.println("Integer");
	}
	输出结果：double【易错】
	分析：jdk1.4-中肯定是double。jdk1.5+虽然有自动拆装箱，但是为了保证向下兼容，所以还是会double



-----------------jdk5.0新特性：增强for循环-----------------
为什么要引入增强for？
	为了替代Iterator。如果实现了Iterator接口，就可以使用增强for循环。增强for的底层实现就是使用Iterator

谁能使用增强for？
	数组；实现了Iterator接口的集合

在集合中使用增强for遍历：
	list set实现了Iterator接口，所以可以使用增强for
	map没有实现Iterator接口，不可以使用增强for



-----------------jdk5.0新特性：可变参数-----------------
	
	public static void main(String[] args) {
		add(1,2);
		add(2,3,4);		
	}
	public static void add(int...nums){
		int sum=0;
		for (int i : nums) {
			sum+=i;
		}
		return sum;
	}

可变参数必须放在最后；只能有一个可变参数




-----------------反射（理解就行）-----------------
应用在一些通用性比较高的代码中
后面学到的框架，大多数都是使用反射来实现的

在框架开发中，都是基于配置文件开发
	在配置文件中配置了类，可以通过反射得到类中的所有内容

类中的所有内容：属性、构造方法、普通方法

反射的原理：
	首先需要把java文件保存到本地硬盘 .java
	编译：.java -> .class文件
	使用jvm，把class文件通过类加载到内存中
	class文件在内存中使用Class类表示

	当使用反射的时候，首先需要获取到Class类。得到了这个类之后，就可以得到class文件里面的所有内容：属性、构造方法、普通方法
	属性通过类Field来表示
	构造方法通过类Constructor来表示
	普通方法通过类Method来表示

获取Class类的三种方法：
	Class c1=Person.class;
	Class c2=new Person("emily").getClass();
	Class c3=Class.forName("emily.Person");	//最常用

[插播：不用new，创建实例对象的方法：]
	Class c1=Class.forName("emily.Person");
	Person p1=(Person)c1.newInstance();


使用反射：（具体见"1114 反射"）

	Class c1 = Class.forName("emily.Person");
	
	// 操作无参数的构造函数
	Person p1=(Person) c1.newInstance();
	
	// 操作有参数的构造函数
	Constructor cs1=c1.getConstructor(String.class);
	Person p2=(Person) cs1.newInstance("小黑黑");
	
	// 操作非private的属性
	Field f1=c1.getDeclaredField("name");
	f1.set(p1, "乌龟");		
	// 操作private的属性
	Field f2=c1.getDeclaredField("age");
	f2.setAccessible(true);
	f2.set(p1, 37);
	p1.show();
	
	// 操作普通方法
	Method m1=c1.getDeclaredMethod("setAge",Integer.class);
	// m1.setAccessible(true);
	m1.invoke(p2, -200);
	p2.show();
	
	// 操作static的属性、方法：对象的位置写null
	// f3.set(null 37);
	// m3.invoke(null, -200);