
-------------变量----------------

变量是内存中的小容器，用来存储数据。那么计算机内存是怎么存储数据的呢？
最小信息单元叫“位（bit）”，我们又称之为“比特位”，通常用小写的字母b表示。而计算机最小的存储单元叫“字节（byte）”，通常用大写字母B表示，字节是由连续的8个位组成。
当程序需要使用存储空间时，操作系统最小会分派给程序1个字节，而不是1个位。

1B(字节) = 1byte = 8bit = 8b
1KB = 1024B
1MB = 1024KB
1GB = 1024MB
1TB = 1024GB
1PB = 1024TB



---------------基本类型：4类8种--------------

整型	
	byte	1字节	-128～127
	short	2		-32768～32767
	int		4		-2147483648～2147483648
	long	8		-2^63～2^63-1
浮点型
	float	4		-3.403E38～3.403E38
	double	8		-1.798E308～1.798E308
字符型
	char	2		表示一个字符，如('a'，'A'，'0'，'家')
布尔型
	boolean	1		只有两个值true与false


---------------常量与类型--------------
100是整数常量，但它是byte、short、int、long中的哪一种呢？
是int，因为默认是int

java中默认的整数类型是int类型
在Java中，整数常量如果不在int取值范围之间，就必须添加“L”后缀（小写的也可以，但建议使用大写），不然会报错。在int取值范围之间的也可以添加“L”后缀。
所有添加了“L”后缀的整数常量都是long类型的，例如：100L、12345678901L都是long类型的常量。

java中默认的浮点类型是double类型
浮点类型的常量也可使用后缀，在Java中所有没有后缀以及使用“D”后缀（小写也可以，但建议使用大写）的小数都是double类型；float类型常量必须添加“F”后缀（小写也可以，但建议使用大写）
3.14没有后缀，所以它是double类型
5.28D为double类型
1.26F为float类型


---------------数据类型转换--------------
1 自动：
	取值范围小的数据类型 -> 范围大的数据类型
	byte -> short -> int -> long -> float -> double
	如：
		double d=100;

2 手动：强制
	范围大 -> 范围小
	如：
		int  i = (int)6.718;   //i的值为6
		或
		double  d = 3.14;
		int  i2 = (int)d;     //i2的值为3

boolean类型不能进行任何类型转换！


	byte b=100;
	b=b+1;	// 报错

	byte b=100;
	b+=1;	// 不报错，相当于b=(byte)b+1;



---------------逻辑运算符--------------

	&	与		false&true		False
	|	或		false|true		True
	^	异或	true^flase		True
	!	非		!true			Flase
	&&	短路与	false&&true		False
	||	短路或	false||true		True

短路与、或：只要能判断出结果则后边的部分就不再运行




---------------Scanner类：输入--------------
包：java.util.Scanner;

	Scanner sc = new Scanner(System.in);
	int n = sc.nextInt();
	String str = sc.next();



---------------Random类：随机数--------------
包：java.util.Random;

	Random r = new Random(); 
	// 随机整数，[0,100)
	int i = r.nextInt(100); 
	// 随机小数，[0.0,1.0)
	double d = r.nextDouble(); 



---------------switch语句--------------
switch (表达式){
	case 目标值1:
		执行语句1
		break;
	．．．．．．
	default:
		执行语句n+1
		break;
}
表达式只能是：byte、short、char、int类型的值
jdk5.0+：枚举
jdk7.0+：String



--------------------------------
数据类型：
	1）基本数据类型：8种
	2）引用数据类型: 数组、类、接口、枚举

包装类：
	int --> Integer
	byte --> Byte
	short --> Short
	long --> Long
	char --> Character
	double --> Double
	float --> Float
	boolean --> Boolean
包装类是对象，可以是null，可以有属性和方法。泛型只能是引用类型



---------------数组-----------------
定义：
	int[] arr = new int[100];	// arr中每个元素都是默认值
	int[] arr=new int[]{1,2,3,4};
	int[] arr={1,2,3,4};

1 引用类型，arr中存的是数组第一个元素的首地址
2 长度固定 arr.length
  只能存一个类型
3 默认值（初始值）：

		数据类型			|		默认初始化值
	byte、short、int、long	|	0
	float、double			|	0.0
	char					|	一个空字符（空格），即’\u0000’
	boolean					|	false
	引用数据类型			|	null，表示变量不引用任何对象
4 异常：
	1 索引越界异常 
		arr[-3]
		arr[201]
	2 空指针异常 
		arr=null;
		arr[2]

5 二维数组
	定义：
		int[][] arr = new int[3][4];
		int[][] arr = {{1,2},{3,4,5,6},{7,8,9}};



---------------方法重载-----------------
根据参数不同，来区分。和返回值无关
System.out.println()就是重载




--------------------------------

	public static void main(String[] args){
		int arr[]={1,2,3};
		change(arr);
		System.out.println(arr[0]);	// 100
	}

	static void change(int[] arr){
		arr[0]=100;
	}

引用类型传参，传的是地址


--------------------------------
java三大特征：继承 + 封装 + 多态

继承：OOP最显著的特性。好处：
	1：提高了代码的复用性。
	2：让类与类之间产生了关系，提供了另一个特征多态的前提。

封装：隐藏内部实现(private)，对外提供借口

多态：
	体现：Animal a = new Cat();
	好处：提高了程序的扩展性。
	弊端：当父类引用指向子类对象时，虽然提高了扩展性，但是只能访问父类中具备的方法，不可以访问子类中特有的方法。



--------------------------------
数组：int[] arr={1,3,5};

集合框架
 
集合和数组的区别：
	1：
		数组：长度固定
		集合：长度可变
	2：
		数组：可存基本+引用数据类型
		集合：只能存引用数据类型
	3：
		数组存储的元素必须是同一个数据类型；
		集合存储的对象可以是不同数据类型。


Iteraotr
	|--Collection：	
		|--Set：无序，不可重复。
	    |--List：有序，可重复
		    |--ArrayList
	|--Map：
		|--HashMap



-----------------JRE和JDK-----------------
JRE： Java Runtime Environment
	包含了java虚拟机，java基础类库
JDK：Java Development Kit
	包含了JRE，同时还包含了编译java源码的编译器javac，还包含了很多java程序调试和分析的工具：jconsole，jvisualvm等工具软件，还包含了java程序编写所需的文档和demo例子程序。

需要运行java程序，只需安装JRE就可以了。如果要编写java程序，需要安装JDK。



-----------------eclipse和myeclipse-----------------
1 eclipse：免费 开发工具
2 myeclipse：收费 插件



-----------------myeclipse快捷键-----------------
代码提示 		Content Assist 		alt+w（改）
快速导包		Organize Imports 	ctrl+shift+o
快速修复		Quick Fix			ctrl+1
单行注释		Toggle Comment 		ctrl+/
多行注释		Add Block Comment	ctrl+shift+/
取消多行注释						ctrl+shift+\
删除行			Delete Line			ctrl+d
代码格式化		Format				ctrl+shift+f

getter		alt+shift+s打开source，选getter



-----------------单元测试junit-----------------
1 测试内容：类中的方法
2 junit不是javase的一部分，想要使用需要导入jar包。但是，myeclipse中自带了junit的jar包。
  junit有不同的版本：3.x 4.x
3 单元测试写法：
	在项目下新建source folder，和src同级，起名为junittt（随便起）
	在junittt中新建一个包，包名需要和"待测试的方法所在类"的包名一致

	@Test：进行单元测试
	@Ignore：不进行单元测试
	@Before：在每个方法之前运行
	@After：在每个方法之后运行
	
	public class 类名随便起 {
		@Test
		public void 方法名随便起(){
			// 测试内容
		}
	}

4 运行：Run As JUnit Test



-----------------list集合-----------------
list：
	1 ArrayList：最有用的List集合实现。由一个整形数字或数组存储了集合的大小（数组中第一个没有使用的元素）。像所有的List集合一样，ArrayList可以在必要的时候扩展它的大小。ArrayList访问元素的时间开销固定。在尾部添加元素成本低（为常数复杂度），而在头部添加元素成本很高（线性复杂度）。这是由ArrayList的实现原理——所有的元素的从角标为0开始一个接着一个排列造成的。也就是说，从要插入的元素位置往后，每个元素都要向后移动一个位置。
	2 linkedList：每一个节点都保存着上一个节点和下一个节点的指针。这就意味着数据的存取和更新具有线性复杂度（这也是一个最佳化的实现，每次操作都不会遍历数组一半以上，操作成本最高的元素就是数组中间的那个）。
	3 Vector：一个带有线程同步方法的ArrayList版本，现在已经被ArrayList代替了

例子：
	List<String> list = new ArrayList<String>();
	// 添加：add()
	list.add("aaa");
	list.add("bbb");
	// 取：get(index)
	System.out.println(list.get(1));


遍历方法：
	1 普通for
		for(int i=0;i<list.size();i++){
			 String txt=list.get(i);
			 System.out.println(txt);
		}
	2 增强for
		for (String txt : list) {
			System.out.println(txt);
		}
	3 迭代器
		Iterator<String> it=list.iterator();
		while(it.hasNext()){
			String txt=it.next();
			System.out.println(txt);
		}



-----------------set集合-----------------
取出顺序和添加顺序无关；不能有重复
	Set<String> set =new HashSet<String>();
	set.add("aaa");
	set.add("bbb");
	set.add("ccc");
	set.add("ddd");
	set.add("bbb");
	for (String string : set) {
		System.out.print(string+'\t');
	}
	输出结果:
		aaa	ddd	ccc	bbb
遍历方法：
	1 增强for
	2 迭代器
		Iterator<String> it=set.iterator();
		while(it.hasNext()){
			String txt=it.next();
			System.out.print(txt+"\t");
		}



-----------------map集合-----------------
HashMap：最常用的Map实现。只是将一个键和值相对应，并没有其他的功能。

	Map<String,Integer> map = new HashMap<String,Integer>();
	map.put("a",1);
	map.put("b",2);
	map.put("c",3);
	System.out.println(map.get("a"));

遍历方法：
	1 获取所有的key，通过key得到value
		Set<String> keySet=map.keySet();
		for(String key:keySet){
			Integer value=map.get(key);
			System.out.println(value);			
		}
		输出结果：2	3 1	
	2 Entry是Map中用来保存一个键值对的，而Map实际上就是多个Entry的集合。
		Set<Entry<String,Integer>> entrySet=map.entrySet();
		for (Entry<String, Integer> entry : entrySet) {
			String key=entry.getKey();
			Integer value=entry.getValue();
			System.out.println(key+": "+value);
		}
		输出结果：
			b: 2
			c: 3
			a: 1



-----------------jdk-----------------
jdk版本：1.1 1.2 1.3 1.4 5.0
jdk5.0新特性：
	泛型
	枚举
	静态导入
	自动拆装箱
	增强for
	可变参数



-----------------jdk5.0新特性：泛型-----------------
泛型里面不能写基本数据类型，要写对应的包装类
	byte		Byte
	short		Short
	int 		Integer
	long 		Long
	folat 		Float
	double 		Double
	char 		Character
	boolean 	Boolean

1 泛型一般使用在集合上，常用集合：list set map
	为什么要使用泛型？
		新元素放入集合后，失去本身的类型，变成Object类型。
		想取出的时候要进行类型转换，很容易出错。
	
2 在方法中使用泛型
	方法逻辑相同，只是数据类型不同
	<T>写在返回值之前，表示任意类型（可以不是T，随便起）

	public static void main(String[] args) {
		// 泛型里不能是基本类型int，必须是包装类Integer	
		Integer[] arr={10,11,12,13,14,15};
		String[] arr2={"a","b","c","d"};
		swap(arr,1,3);
		swap(arr2,1,3);
		System.out.println(Arrays.toString(arr));
		System.out.println(Arrays.toString(arr2));		
	}
	private static <T> void swap(T[] arr,int i,int j){
		T temp;
		temp=arr[i];
		arr[i]=arr[j];
		arr[j]=temp;
	}

3 在类中使用泛型（不常用，了解即可）
	public class Test<T>{
		T num;

		void func(T sum){}

		// static的不能用泛型，下面两行都会报错
		// static T num2;
		// static void func2(T sum){}

		// 下面的不报错：
		static <T2> void fun3(T2 sum){}

	}

4 泛型擦除
	泛型只存在于源代码中，编译后就不存在了


-----------------jdk5.0新特性：枚举-----------------
需要在一定的范围内取值（红绿灯）

枚举是一种特殊的类。
枚举类中声明的每一个枚举值，都是枚举类的一个实例对象。
与java中的普通类一样，在声明枚举类时，也可以声明属性、方法和构造函数，但构造函数必须是private的。
枚举类可以实现接口、继承抽象类。
jdk5中扩展了switch语句，它除了可以接受int byte char short之外，还可以接收一个枚举类型。

	public class MeiJu {
		public static void main(String[] args) {		
			Color color=Color.GREEN;
		}
	}
	enum Color{
		RED,GREEN,YELLOW;
	}
	class Color2{
		public static final Color2 RED=new Color2();
		public static final Color2 GREEN=new Color2();
		public static final Color2 YELLOW=new Color2();
	}
	(枚举类Color是Color2的简写形式)	
	------------------------------
	public class MeiJu {
		public static void main(String[] args) {		
			Color color=Color.GREEN;
			color.show();
		}
	}
	enum Color{
		RED("red",1),GREEN("green",2),YELLOW("yellow",3);
		private String name;
		private Integer level;
		private Color(String name,Integer level){
			this.name=name;
			this.level=level;
		}
		public void show(){
			System.out.println("颜色："+this.name+"；重要级别："+this.level);
		}
	}

常用方法：
	color.name()：返回枚举的名称
	color.ordinal()：返回枚举的下标（从0开始）

还有两个方法不在API里面，但是编译的时候会生成：
	Color.valueof(String name)：返回枚举对象
	Color.values()：返回所有枚举对象数组

练习：枚举对象、枚举对象下标、枚举对象名称之间的转换



-----------------jdk5.0新特性：静态导入-----------------
了解即可，不常用。容易出错

可以在代码里面，直接导入静态方法或常量

	import static java.lang.System.out;
	import static java.lang.Math.abs;

	public class staticImport {
		public static void main(String[] args) {
			double num=abs(-2.9);
			out.println(num);			
		}
	}



-----------------jdk5.0新特性：自动拆装箱-----------------
基本类型 <----> 包装类 自动转换

	Integer i=10;	// 自动装箱
	int j=i;		// 自动拆箱

jdk1.4-中不能自动转换，上面的写法会报错，需要：
	Integer i=new Integer(10);
	int j=i.intValue();
jdk是向下兼容的，所以在jdk1.5+中上面两行可以运行	

	public static void main(String[] args) {
		doo(1);		
	}
	private static void doo(double d){
		System.out.println("double");
	}

	private static void doo(Integer i){
		System.out.println("Integer");
	}
	输出结果：double【易错】
	分析：jdk1.4-中肯定是double。jdk1.5+虽然有自动拆装箱，但是为了保证向下兼容，所以还是会double



-----------------jdk5.0新特性：增强for循环-----------------
为什么要引入增强for？
	为了替代Iterator。如果实现了Iterator接口，就可以使用增强for循环。增强for的底层实现就是使用Iterator

谁能使用增强for？
	数组；实现了Iterator接口的集合

在集合中使用增强for遍历：
	list set实现了Iterator接口，所以可以使用增强for
	map没有实现Iterator接口，不可以使用增强for



-----------------jdk5.0新特性：可变参数-----------------
	
	public static void main(String[] args) {
		add(1,2);
		add(2,3,4);		
	}
	public static void add(int...nums){
		int sum=0;
		for (int i : nums) {
			sum+=i;
		}
		return sum;
	}

可变参数必须放在最后；只能有一个可变参数




-----------------反射（理解就行）-----------------
应用在一些通用性比较高的代码中
后面学到的框架，大多数都是使用反射来实现的

在框架开发中，都是基于配置文件开发
	在配置文件中配置了类，可以通过反射得到类中的所有内容

类中的所有内容：属性、构造方法、普通方法

反射的原理：
	首先需要把java文件保存到本地硬盘 .java
	编译：.java -> .class文件
	使用jvm，把class文件通过类加载到内存中
	class文件在内存中使用Class类表示

	当使用反射的时候，首先需要获取到Class类。得到了这个类之后，就可以得到class文件里面的所有内容：属性、构造方法、普通方法
	属性通过类Field来表示
	构造方法通过类Constructor来表示
	普通方法通过类Method来表示

获取Class类的三种方法：
	Class c1=Person.class;
	Class c2=new Person("emily").getClass();
	Class c3=Class.forName("emily.Person");	//最常用

[插播：不用new，创建实例对象的方法：]
	Class c1=Class.forName("emily.Person");
	Person p1=(Person)c1.newInstance();


使用反射：

	Class c1 = Class.forName("emily.Person");
	
	// 操作无参数的构造函数
	Person p1=(Person) c1.newInstance();
	
	// 操作有参数的构造函数
	Constructor cs1=c1.getConstructor(String.class);
	Person p2=(Person) cs1.newInstance("小黑黑");
	
	// 操作非private的属性
	Field f1=c1.getDeclaredField("name");
	f1.set(p1, "乌龟");		
	// 操作private的属性
	Field f2=c1.getDeclaredField("age");
	f2.setAccessible(true);
	f2.set(p1, 37);
	p1.show();
	
	// 操作普通方法
	Method m1=c1.getDeclaredMethod("setAge",Integer.class);
	// m1.setAccessible(true);
	m1.invoke(p2, -200);
	p2.show();
	
	// 操作static的属性、方法：对象的位置写null
	// f3.set(null 37);
	// m3.invoke(null, -200);



-----------------java画图-----------------		
生成验证码：
	
	// 得到图片缓冲区
	BufferedImage bi=new BufferedImage(70, 30, BufferedImage.TYPE_INT_RGB);
	
	// 得到它的绘制环境
	Graphics2D g2=(Graphics2D) bi.getGraphics();
	
	// 设置颜色
	g2.setColor(Color.PINK);		
	// 画一个矩形，填充整张图片（相当于设置了背景色）
	g2.fillRect(0, 0, 70, 30);
	

	// 设置颜色
	g2.setColor(Color.BLACK);	
	// 设置字体
	g2.setFont(new Font("微软雅黑",Font.ITALIC,16));
	// 写字
	g2.drawString("hello", 15,20);
	
	// 保存图片
	try {
		ImageIO.write(bi, "JPEG", new FileOutputStream("E:/hello.jpg"));
	} catch (FileNotFoundException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	} catch (IOException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}