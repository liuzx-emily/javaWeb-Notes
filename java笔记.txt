



-----------------变量--------------------【START】

变量是内存中的小容器，用来存储数据。那么计算机内存是怎么存储数据的呢？
最小信息单元叫“位（bit）”，我们又称之为“比特位”，通常用小写的字母b表示。而计算机最小的存储单元叫“字节（byte）”，通常用大写字母B表示，字节是由连续的8个位组成。
当程序需要使用存储空间时，操作系统最小会分派给程序1个字节，而不是1个位。

1B(字节) = 1byte = 8bit = 8b
1KB = 1024B
1MB = 1024KB
1GB = 1024MB
1TB = 1024GB
1PB = 1024TB



---------------基本类型：4类8种--------------

整型	
	byte	1字节	-128～127
	short	2		-32768～32767
	int		4		-2147483648～2147483648
	long	8		-2^63～2^63-1
浮点型
	float	4		-3.403E38～3.403E38
	double	8		-1.798E308～1.798E308
字符型
	char	2		表示一个字符，如('a'，'A'，'0'，'家') 0~65535
布尔型
	boolean	1		只有两个值true与false




---------------char--------------
char可以自动转成int类型，会查询编码表，得到整数
int转成char时，需要强制转换，查询编码表

打印a-z：
	char c='a';
	for(int i=0;i<26;i++){
		System.out.println(c);
		c++;
	}




---------------常量与类型--------------
100是整数常量，但它是byte、short、int、long中的哪一种呢？
是int，因为默认是int

java中默认的整数类型是int类型
在Java中，整数常量如果不在int取值范围之间，就必须添加“L”后缀（小写的也可以，但建议使用大写），不然会报错。在int取值范围之间的也可以添加“L”后缀。
所有添加了“L”后缀的整数常量都是long类型的，例如：100L、12345678901L都是long类型的常量。

java中默认的浮点类型是double类型
浮点类型的常量也可使用后缀，在Java中所有没有后缀以及使用“D”后缀（小写也可以，但建议使用大写）的小数都是double类型；float类型常量必须添加“F”后缀（小写也可以，但建议使用大写）
3.14没有后缀，所以它是double类型
5.28D为double类型
1.26F为float类型




---------------数据类型转换--------------
1 自动：
	取值范围小的数据类型 -> 范围大的数据类型
	byte -> short -> int -> long -> float -> double
	如：
		double d=100;

2 手动：强制
	范围大 -> 范围小
	如：
		int  i = (int)6.718;   //i的值为6
		或
		double  d = 3.14;
		int  i2 = (int)d;     //i2的值为3

boolean类型不能进行任何类型转换！


	byte b=100;
	b=b+1;	// 报错

	byte b=100;
	b+=1;	// 不报错，相当于b=(byte)b+1;




---------------逻辑运算符--------------

	&	与		false&true		False
	|	或		false|true		True
	^	异或	true^flase		True
	!	非		!true			Flase
	&&	短路与	false&&true		False
	||	短路或	false||true		True

短路与、或：只要能判断出结果则后边的部分就不再运行




---------------Scanner类：输入--------------
包：java.util.Scanner;

	Scanner sc = new Scanner(System.in);
	int n = sc.nextInt();
	String str = sc.next();



---------------Random类：随机数--------------
包：java.util.Random;

	Random r = new Random(); 
	// 随机整数，[0,100)
	int i = r.nextInt(100); 
	// 随机小数，[0.0,1.0)
	double d = r.nextDouble(); 



---------------switch语句--------------
switch (表达式){
	case 目标值1:
		执行语句1
		break;
	．．．．．．
	default:
		执行语句n+1
		break;
}
表达式只能是：byte、short、char、int类型的值
jdk5.0+：枚举
jdk7.0+：String



--------------------------------
数据类型：
	1）基本数据类型：8种
	2）引用数据类型: 数组、类、接口、枚举
		ArrayList是集合，集合是特殊的类。

包装类：
	int --> Integer
	byte --> Byte
	short --> Short
	long --> Long
	char --> Character
	double --> Double
	float --> Float
	boolean --> Boolean
包装类是对象，可以是null，可以有属性和方法。泛型只能是引用类型



---------------数组-----------------
定义：
	int[] arr = new int[100];	// arr中每个元素都是默认值
	int[] arr=new int[]{1,2,3,4};
	int[] arr={1,2,3,4};

1 引用类型，arr中存的是数组第一个元素的首地址
2 长度固定 arr.length
  只能存一个类型
3 默认值（初始值）：

		数据类型			|		默认初始化值
	byte、short、int、long	|	0
	float、double			|	0.0
	char					|	一个空格，即’\u0000’
	boolean					|	false
	引用数据类型			|	null
4 异常：
	1 索引越界异常 
		arr[-3]
		arr[201]
	2 空指针异常 
		arr=null;
		arr[2]

5 二维数组
	定义：
		int[][] arr = new int[3][4];
		int[][] arr = {{1,2},{3,4,5,6},{7,8,9}};



---------------方法重载-----------------
根据参数不同，来区分。和返回值无关
System.out.println()就是重载




--------------------------------

	public static void main(String[] args){
		int arr[]={1,2,3};
		change(arr);
		System.out.println(arr[0]);	// 100
	}

	static void change(int[] arr){
		arr[0]=100;
	}

引用类型传参，传的是地址



--------------------------------

	Phone phone=new Phone();
内存中发生了什么？
	JVM在堆内存中开辟了一块空间，存储新new的对象
	属性也跟着进入堆内存，赋予默认值。
	JVM把这块内存的地址，传递给p。p中保存的是新对象在内存中的地址。




---------------ArrayList----------------
为了保存数目不确定的元素，JDK中提供了一系列特殊的类，这些类可以存储任意类型的元素，并且长度可变，统称为集合。
ArrayList集合是程序中最常见的一种集合，它属于引用数据类型中的类。

	ArrayList<String> arr1=new ArrayList<String>();
	ArrayList<Integer> arr2=new ArrayList<Integer>();

包：java.util.ArrayList
只能存储引用类型，不能存基本类型，要用包装类。
存：add()
取：get()
长度：size()
不常用方法：
	boolean add（int index,  Object obj）	将指定元素obj插入到集合中指定的位置
	Object remve（int index）	从集合中删除指定index处的元素，返回该元素
	void clear()	清空集合中所有元素
	Object set（int index, Object obj）	用指定元素obj替代集合中指定位置上的元素




--------------------------------

java不允许多继承，因为有安全问题。用多实现。


子类、父类中，出现重名的field、方法时，默认用子类的，想要用父类需要指明super.xxx




--------------抽象类 抽象方法----------------

	abstract class Worker {
		public abstract void work();
	}

1、抽象类和抽象方法都需要被abstract修饰。抽象方法一定要定义在抽象类中。
2、抽象类不可以new
3、只有覆盖了抽象类中所有的抽象方法后，其子类才可以创建对象。否则该子类还是一个抽象类。

4、abstract不可以和哪些关键字共存？	
1、private
2、final
3、static




--------------接口----------------
	public interface Animal{
		public abstract void eat();
	}

1 是比抽象类更为抽象的”类”。不能new
2 将功能的"定义"与"实现"分离

3 接口中的方法：
	只能是public abstract的，可以省略不写
	接口中：void eat();		// 等价于public abstract void eat();
	
4 接口中的成员变量：
	只能是public static final的，可以省略不写，
  	接口中：int a=1; 		// 等价于public static final int a=1;
  	可以直接：接口.a

5 实现类，必须重写接口中的【所有】抽象方法
  如果没有重写所有，那么实现类还是一个抽象类

6 为什么要定义接口，和抽象类相比有什么优势？
	解决多继承的弊端。将多继承通过多实现完成了。

7 父类中定义的事物的基本功能。接口中定义的事物的扩展功能。
	class 缉毒犬 extends 犬科 implements 缉毒

8 多个接口之间可以使用extends进行继承。
	interface Fu1{
		void show1();
	}
	interface Fu2{
		void show2();
	}
	interface Zi extends Fu1,Fu2{
		void show3();
	}

接口没有构造方法

抽象类&接口的选用:
优先选用接口,尽量少用抽象类;
需要为子类提供共性功能时才选用抽象类;




--------------------------------
java三大特征：继承 + 封装 + 多态

多态：
	体现：Animal a = new Cat();
	好处：提高了程序的扩展性。
	弊端：不可以访问子类中特有的方法。



----------------多态----------------
1 field：当子父类中出现同名的成员变量时，多态调用该变量时
	class Fu {
		int num = 4;
	}
	class Zi extends Fu {
		int num = 5;
	}
	public class Demo {
		public static void main(String[] args) 	{
			Fu f = new Zi();
			System.out.println(f.num);	// 4
			Zi z = new Zi();
			System.out.println(z.num);	// 5
		}
	}

2 method：当子父类中出现同名的成员方法时，多态调用该方法时：
		编译看左边，运行看右边。
	
	class Fu {
		int num = 4;
		void show()	{
			System.out.println("Fu show num");
		}
	}
	class Zi extends Fu {
		int num = 5;
		void show()	{
			System.out.println("Zi show num");
		}
	}
	class Demo {
		public static void main(String[] args) 	{
			Fu f = new Zi();
			f.show();	// Zi show num
		}
	}




----------------instanceof----------------

	Person p1 = new Student();
	boolean flag1 = p1 instanceof Student; 	// true
	boolean flag2 = p1 instanceof Teacher; 	// false
	boolean flag3 = p1 instanceof Person; 	// true




----------------多态 转型----------------
向上转型：
	Person p = new Student();
向下转型：
	Student stu = (Student) p;

什么时候使用upcasting：使用父类的功能就能完成相应的操作，如：
		Animal a = new Dog();
	    a.eat();

什么时候使用downcasting：
	当要使用子类特有功能时，如：
		Dog d = (Dog) a;
		d.lookHome();
	弊端：容易发生ClassCastException类型转换异常。在转换之前必须做类型判断，如：
		if( !a instanceof Dog)




----------------构造方法----------------
1 默认构造方法
	如果没有写构造方法，在编译时，编译器会自动添加默认的空构造方法

2 一个类中可以有多个构造方法，多个构造方法是以重载的形式存在的
  构造方法之间的调用，可以通过this关键字来完成。
  调用其他构造方法的语句必须定义在构造方法的第一行。

3 构造方法是可以被private修饰的，作用：其他程序无法创建该类的对象




----------------this super---------------
1 this：
	一个构造方法调用另一个构造方法
	this.field

2 super：
	在创建子类对象时，父类的构造方法会先执行，因为子类中所有构造方法的第一行有默认的隐式super();语句。
	当父类中没有空参数构造方法时，子类的构造方法必须有显示的super语句。
	
	如果子类的构造方法第一行写了this调用了子类的其他构造方法，那么super调用父类的语句还有吗？————没有了。

	父类构造方法中是否有隐式的super呢？
	也是有的。记住：只要是构造方法默认第一行都是super();
	父类的父类是谁呢？super调用的到底是谁的构造方法呢？————Object类




----------------继承中的构造方法---------------

1 如果我们没写任何的构造方法，编译器提供给我们一个空参数构造方法
  如果我们手动给出了构造方法，编译器不会再给我们提供默认的空参数构造方法

2 在构造方法中，默认的第一条语句为 super();
  它是用来访问父类中的空参数构造方法，进行父类成员的初始化操作

3 当父类中没有空参数构造方法的时候，怎么办？
	a: 通过 super(参数) 访问父类有参数的构造方法
	b: 通过 this(参数) 访问本类中其他构造方法，其他构造方法需要调用了有参super

4 super(参数) 与 this(参数) 不能同时在构造方法中存在






----------------final---------------
final是个修饰符，它可以用来修饰：
	类
	类的成员：field method
	局部变量

1 final修饰的类不可以被继承。但是可以继承其他类。

2 final修饰的方法不可以被覆盖。但父类中没有被final修饰方法，子类覆盖后可以加final。

3 final修饰的变量称为常量，这些变量只能赋值一次。在编译生成.class文件后，该变量变为常量值
	final int i = 20;
	i = 30; 			// 报错

  引用类型的变量值为地址，地址值不能更改，但是地址内的对象属性值可以修改。
	final Person p = new Person();
	Person p2 = new Person();
	p = p2; 			// 报错
	p.name = "小明";	// ok

4 final修饰的成员变量，需要在创建对象前赋值，否则报错。
	class Demo {
		//直接赋值
		final int m = 100;
		
		//final修饰的成员变量，需要在创建对象前赋值，否则报错。
		final int n; 
		public Demo(){
			//可以在创建对象时所调用的构造方法中，为变量n赋值
			n = 2016;
		}
	}





----------------static---------------
特点：
	被所有的对象所共享
	可以通过类名直接调用

注意事项：
	static的成员，随着类的加载而加载，优先于对象存在
	在static方法中，不能使用this super
	在static方法中，只能调用static的变量、方法


使用public static final来定义静态常量。此时变量名用全部大写，多个单词使用下划线连接。

	class Company {
		public static final String COMPANY_NAME = "SLA";
	}

	System.out.println(Company.COMPANY_NAME); //打印传智播客
	

注意：
	接口中的每个成员变量都默认使用public static final修饰。由于接口没有构造方法，所以必须显示赋值。
	interface Inter {
		public static final int COUNT = 100;
	}

	Inter.COUNT




----------------内部类---------------

1 内部类：在一个类中，定义了一个新类，这个新的类就是内部类
  内部类分为成员内部类与局部内部类

2 成员内部类

	class Body {
		private boolean life= true;
	    public class Heart {
			public void jump() {
				System.out.println("生命状态" + life);
			}
		}
		public static void main(String[] args) {
			Body.Heart bh = new Body().new Heart();
			bh.jump();
		}
	}

3 局部内部类
	class Party {
		public void puffBall(){
			class Ball {
	            public void puff(){System.out.println("气球膨胀了");}
			}	
			new Ball().puff();
		}
		public static void main(String[] args) {
			Party p = new Party();
			p.puffBall();
		}
	}

4 内部类的实际使用：匿名内部类
	内部类是为了应对更为复杂的类间关系。查看源代码中会涉及到，而在日常业务中很难遇到
	最常用到的内部类就是匿名内部类，它是局部内部类的一种。

		public abstract class Person{
			public abstract void eat();
		}
		Person  p = new Person(){
			public void eat() {
				System.out.println("eat.....");
			}
		};
		p.eat();

	详见：https://www.cnblogs.com/nerxious/archive/2013/01/25/2876489.html




----------------权限修饰符---------------

					public	protected	默认的	private
在当前类中			Y		Y			Y		Y
同一包中的其他类	Y		Y			Y
不同包中的子类		Y		Y	
不同包中的其他类	Y

归纳一下：
	要想仅能在本类中访问：private
	要想本包中的类都可以访问不加修饰符即可；
	要想本包中的类与其他包中的子类可以访问：protected
	要想所有包中的所有类都可以访问：public

易错：
	不写修饰符的，在其他包中的子类里不能用

注意：如果类用public修饰，则类名必须与文件名相同。一个文件中只能有一个public修饰的类。




----------------protected---------------
protected：
	1 同一包中的类可以用
	2 其他包中的子类可以用，但是只能在子类的里面调用！！

		public class A{
			protected void func(){}
		}
		
		// 另一个包中：
		public class B extends A{
			void func2(){
				func();				// ok
				new A().func();		// 报错
			}
			public static void main(String[] args){
				new B().func();		// ok
				new A().func();		// 报错
			}
		}


--------------------------------
集合和数组的区别：

	1： 数组：长度固定
		集合：长度可变

	2： 数组：基本、引用都能存
		集合：只能存引用

	3： 数组存储的元素必须是同一个数据类型；
		集合存储的对象可以是不同数据类型。



-----------------list集合-----------------
list：
	1 ArrayList：最有用的List集合实现。由一个整形数字或数组存储了集合的大小（数组中第一个没有使用的元素）。像所有的List集合一样，ArrayList可以在必要的时候扩展它的大小。ArrayList访问元素的时间开销固定。在尾部添加元素成本低，而在头部添加元素成本很高。
	2 linkedList：每一个节点都保存着上一个节点和下一个节点的指针。这就意味着数据的存取和更新具有线性复杂度（这也是一个最佳化的实现，每次操作都不会遍历数组一半以上，操作成本最高的元素就是数组中间的那个）。

例子：
	List<String> list = new ArrayList<String>();
	add()
	get()


遍历方法：
	1 普通for
		for(int i=0;i<list.size();i++){
			 String txt=list.get(i);
			 System.out.println(txt);
		}
	2 增强for
		for (String txt : list) {
			System.out.println(txt);
		}
	3 迭代器
		Iterator<String> it=list.iterator();
		while(it.hasNext()){
			String txt=it.next();
			System.out.println(txt);
		}



-----------------set集合-----------------
取出顺序和添加顺序无关；不能有重复
	Set<String> set =new HashSet<String>();
	set.add("aaa");
	set.add("bbb");
	set.add("ccc");
	set.add("ddd");
	set.add("bbb");
	for (String string : set) {
		System.out.print(string+'\t');
	}
	输出结果:
		aaa	ddd	ccc	bbb
遍历方法：
	1 增强for
	2 迭代器
		Iterator<String> it=set.iterator();
		while(it.hasNext()){
			String txt=it.next();
			System.out.print(txt+"\t");
		}



-----------------map集合-----------------
HashMap：最常用的Map实现。只是将一个键和值相对应，并没有其他的功能。

	Map<String,Integer> map = new HashMap<String,Integer>();
	
	put()
	get()

遍历方法：
	1 获取所有的key，通过key得到value
		Set<String> keySet=map.keySet();
		for(String key:keySet){
			Integer value=map.get(key);
			System.out.println(value);			
		}
		输出结果：2	3 1	
	2 Entry是Map中用来保存一个键值对的，而Map实际上就是多个Entry的集合。
		Set<Entry<String,Integer>> entrySet=map.entrySet();
		for (Entry<String, Integer> entry : entrySet) {
			String key=entry.getKey();
			Integer value=entry.getValue();
			System.out.println(key+": "+value);
		}
		输出结果：
			b: 2
			c: 3
			a: 1



-----------------jdk-----------------
jdk版本：1.1   1.2   1.3   1.4   5.0（变化很大，所以不叫1.5，叫5.0）
jdk5.0新特性：
	泛型
	枚举
	静态导入
	自动拆装箱
	增强for
	可变参数



-----------------jdk5.0新特性：泛型-----------------
泛型里面不能写基本数据类型，要写对应的包装类（因为集合中只能存引用，不能存基本）
	byte		Byte
	short		Short
	int 		Integer
	long 		Long
	folat 		Float
	double 		Double
	char 		Character
	boolean 	Boolean

1 泛型一般使用在集合上，常用集合：list set map
	为什么要使用泛型？
		新元素放入集合后，失去本身的类型，变成Object类型。
		想取出的时候要进行类型转换，很容易出错。
	
2 在方法中使用泛型
	方法逻辑相同，只是数据类型不同
	<T>写在返回值之前，表示任意类型（可以不是T，随便起）

	public static void main(String[] args) {
		// 泛型里不能是基本类型int，必须是包装类Integer	
		Integer[] arr={10,11,12,13,14,15};
		String[] arr2={"a","b","c","d"};
		swap(arr,1,3);
		swap(arr2,1,3);
		System.out.println(Arrays.toString(arr));
		System.out.println(Arrays.toString(arr2));		
	}
	private static <T> void swap(T[] arr,int i,int j){
		T temp;
		temp=arr[i];
		arr[i]=arr[j];
		arr[j]=temp;
	}

3 在类中使用泛型（不常用，了解即可）
	public class Test<T>{
		T num;

		void func(T sum){}

		// static的不能用泛型，下面两行都会报错
		// static T num2;
		// static void func2(T sum){}

		// 下面的不报错：
		static <T2> void fun3(T2 sum){}

	}

4 泛型擦除
	泛型只存在于源代码中，编译后就不存在了




-----------------jdk5.0新特性：枚举-----------------
需要在一定的范围内取值（红绿灯）

枚举是一种特殊的类。
枚举类中声明的每一个枚举值，都是枚举类的一个实例对象。
与java中的普通类一样，在声明枚举类时，也可以声明属性、方法和构造函数，但构造函数必须是private的。
枚举类可以实现接口、继承抽象类。
jdk5中扩展了switch语句，它除了可以接受 byte short char int之外，还可以接收枚举类型。

	http://blog.csdn.net/qq_27093465/article/details/52180865

常用方法：
	color.name()：返回枚举的名称
	color.ordinal()：返回枚举的下标（从0开始）

还有两个方法不在API里面，但是编译的时候会生成：
	Color.valueof(String name)：返回枚举对象
	Color.values()：返回所有枚举对象数组




-----------------jdk5.0新特性：静态导入-----------------
了解即可，不常用。容易出错

可以在代码里面，直接导入静态方法或常量

	import static java.lang.System.out;
	import static java.lang.Math.abs;

	public class staticImport {
		public static void main(String[] args) {
			double num=abs(-2.9);
			out.println(num);			
		}
	}




-----------------jdk5.0新特性：自动拆装箱-----------------
基本类型 <----> 包装类 自动转换

	Integer i=10;	// 自动装箱
	int j=i;		// 自动拆箱

jdk1.4-中不能自动转换，上面的写法会报错，需要：
	Integer i=new Integer(10);
	int j=i.intValue();
jdk是向下兼容的，所以在jdk1.5+中上面两行可以运行	

	public static void main(String[] args) {
		doo(1);		
	}
	private static void doo(double d){
		System.out.println("double");
	}

	private static void doo(Integer i){
		System.out.println("Integer");
	}
	输出结果：double
	分析：jdk1.4-中肯定是double。jdk1.5+虽然有自动拆装箱，但是为了保证向下兼容，所以还是double




-----------------jdk5.0新特性：增强for循环-----------------
为什么要引入增强for？
	为了替代Iterator。如果实现了Iterator接口，就可以使用增强for循环。增强for的底层实现就是使用Iterator

谁能使用增强for？
	数组；实现了Iterator接口的集合

在集合中使用增强for遍历：
	list set实现了Iterator接口，所以可以使用增强for
	map没有实现Iterator接口，不可以使用增强for




-----------------jdk5.0新特性：可变参数-----------------
	
	public static void main(String[] args) {
		add(1,2);
		add(2,3,4);		
	}
	public static void add(int...nums){
		int sum=0;
		for (int i : nums) {
			sum+=i;
		}
		return sum;
	}

可变参数必须放在最后；只能有一个可变参数




-----------------反射（理解就行）-----------------
应用在一些通用性比较高的代码中
后面学到的框架，大多数都是使用反射来实现的

在框架开发中，都是基于配置文件开发
	在配置文件中配置了类，可以通过反射得到类中的所有内容

类中的所有内容：属性、构造方法、普通方法

反射的原理：
	首先需要把java文件保存到本地硬盘 .java
	编译：.java -> .class文件
	使用jvm，把class文件通过类加载到内存中。class文件在内存中使用Class类表示

	当使用反射的时候，首先需要获取到Class类。得到了这个类之后，就可以得到class文件里面的所有内容：属性、构造方法、普通方法
	属性通过类Field来表示
	构造方法通过类Constructor来表示
	普通方法通过类Method来表示

获取Class类的最常用方法：
	Class c3=Class.forName("emily.Person");

[不用new，创建实例对象的方法：]
	Class c1=Class.forName("emily.Person");
	Person p1=(Person)c1.newInstance();


使用反射：

	Class c1 = Class.forName("emily.Person");
	
	// 操作无参数的构造函数
	Person p1=(Person) c1.newInstance();
	
	// 操作有参数的构造函数
	Constructor cs1=c1.getConstructor(String.class);
	Person p2=(Person) cs1.newInstance("小黑黑");
	
	// 操作非private的属性
	Field f1=c1.getDeclaredField("name");
	f1.set(p1, "乌龟");		
	// 操作private的属性
	Field f2=c1.getDeclaredField("age");
	f2.setAccessible(true);
	f2.set(p1, 37);
	
	// 操作普通方法
	Method m1=c1.getDeclaredMethod("setAge",Integer.class);
	m1.setAccessible(true);
	m1.invoke(p2, -200);
	p2.show();
	
	// 操作static的属性、方法：对象的位置写null
	f3.set(null,37);
	m3.invoke(null, -200);




-----------------java画图-----------------		
生成验证码：
	
	// 得到图片缓冲区
	BufferedImage bi=new BufferedImage(70, 30, BufferedImage.TYPE_INT_RGB);
	
	// 得到它的绘制环境
	Graphics2D g2=(Graphics2D) bi.getGraphics();
	
	// 设置颜色
	g2.setColor(Color.PINK);		
	// 画一个矩形，填充整张图片（相当于设置了背景色）
	g2.fillRect(0, 0, 70, 30);
	

	// 设置颜色
	g2.setColor(Color.BLACK);	
	// 设置字体
	g2.setFont(new Font("微软雅黑",Font.ITALIC,16));
	// 写字
	g2.drawString("hello", 15,20);
	
	// 保存图片
	try {
		ImageIO.write(bi, "JPEG", new FileOutputStream("E:/hello.jpg"));
	} catch (FileNotFoundException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	} catch (IOException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}




-----------------Object类-----------------
Object类是Java语言中的根类，即所有类的父类。

1 Object中的equals方法：	
	// 比较的是地址
	public boolean equals(Object obj) {
        return (this == obj);
    }

  子类重写equals方法：

  	public class Person {
  		
  		private int id = 0;
  		
  		@Override
  		public boolean equals(Object obj) {
  			if (obj instanceof Person) {
  				Person p=(Person) obj;
  				return this.id==p.id;	// 问题：为什么能取private的p.id？？
  			}else{
  				return false;
  			}
  		}
  		
  	}

2 Object中的toString方法：返回对象的类型+@+内存地址值
	
  在输出语句中，如果写的是对象，那么会默认调用对象的toString方法:
	System.out.println(p);	// 等价于下面一行
	System.out.println(p.toString());

  子类重写toString方法：
  	public class Person {
  		
  		private String name;
  		
  		Person(String name){
  			this.name=name;
  		}

  		@Override
  		public String toString() {
  			return "这个人的名字是"+this.name;
  		}
  		
  		public static void main(String[] args) {
  			Person person=new Person("小红");
  			System.out.println(person);	// 不需要写person.toString()
  		}
  	}





-----------------String类-----------------
Java 程序中的所有字符串字面值（如 "abc" ）都是String类的对象
	String str="abc";	// "abc"是String类的对象。str是引用，存的是地址

为什么输出str没有显示地址？
	————因为String类重写了toString方法

字符串的值在创建之后不能更改。就是说一旦这个字符串确定了，那么在内存区域中就生成了这个字符串，字符串本身不能改变。
"abc"这个对象不能改变，但是变量str中的地址是可以改变的。
	String str="abc";
	str="def";	// "abc"对象不变。新建了一个String类对象"def"，把它的地址给str

通过使用双引号的方式创建对象与new的方式创建对象，有什么不同呢？
	String s3 = "abc";
	String s4 = new String("abc");
	System.out.println(s3==s4); //false
	System.out.println(s3.equals(s4)); //true,因为String重写了equals方法

	s3创建，在内存中只有一个对象"abc"。这个对象在字符串常量池中
	s4创建，在内存中有两个对象。一个new的对象在堆中，一个字符串本身对象"abc"在字符串常量池中

length()

substring(int beginindex)
substring(int beginindex,int endIndex) 包括起，不包括尾。返回新字符串

boolean startsWith(String prefix);
boolean endsWith(String suffix);
boolean contains(String s);
int indexOf(String str);	// 查找第一次出现的索引，没有就-1
int indexOf(String str,int fromIndex);

char[] toCharArray();	// 转成字符数组

booleans equals(Object anObject);
booleans equalsIgnoreCase(String anotherString);

String replace(char old,char new);
String replace(String old,String new);
String trim() 去除字符串两端空格，中间的不会去除，返回一个新字符串
String toLowerCase();
String toUpperCase();




-----------------StringBuilder-----------------
String浪费内存，所以StringBuffer

StringBuilder类，也是字符串缓冲区，它和StringBuffer有什么不同呢？
	————此类提供一个与 StringBuffer 兼容的 API，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。

StringBuffer append(String str)
StringBuffer insert(int offset,String str)
StringBuffer deleteCharAt(int index)
StringBuffer delete(int start,int end)
StringBuffer replace(int start,int end,String str)
StringBuffer reverse()
String substring(int start) 
String substring(int start,int end) 




-----------------正则-----------------
String类中正则相关的方法：
	boolean matches(String regex);
	String[] split(String regex);
	String replaceAll(String regex,String replacement);


	String s = "Hello12345World6789012";
	String regex = "\\d";
	String result = s.replaceAll(regex, "*");	// Hello*****World*******




-----------------Date-----------------
时间和日期类：java.util.Date  

毫秒的0点: 
   System.currentTimeMillis() 返回long
   获取当前日期的毫秒值
   时间原点：1970年1月1日 0:00:00 英国格林威治 毫秒值是0
	long time = System.currentTimeMillis();
	System.out.println(time);

重要: 时间和日期的计算,必须依赖毫秒值
	XXX-XXX-XX = 毫秒


	Date date = new Date();		// 当前操作系统中的时间和日期

	/*
	 * Date类的long参数的构造方法
	 * 传递毫秒值,将毫秒值转成对应的日期对象
	 */
	Date date = new Date(0); 	
	System.out.println(date);	// Thu Jan 01 08:00:00 CST 1970

	/*
	 * Date类方法 setTime(long)传递毫秒值
	 */
	Date date = new Date();
	date.setTime(0);

	
	/*
	 *   Date类方法 getTime() 返回值long 毫秒值
	 */
	Date date = new Date();
	long time = date.getTime();




-----------------Date转String-----------------
格式化输出Date:

	对日期格式化的类 java.text.DateFormat 抽象类, 普通方法+抽象方法
	实际使用是子类 java.text.SimpleDateFormat 可以使用父类普通方法,重写了抽象方法

	/*
	 * 如何对日期格式化
	 *  步骤:
	 *    1. 创建SimpleDateFormat对象
	 *       在类构造方法中,写入字符串的日期格式 (自己定义)
	 *    2. SimpleDateFormat调用方法format对日期进行格式化
	 *         String format(Date date) 传递日期对象,返回字符串
	 *    日期模式:
	 *       yyyy    年份
	 *       MM      月份
	 *       dd      月中的天数
	 *       HH      0-23小时
	 *       mm      分钟
	 *       ss      秒
	 */
	SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 HH点mm分钟ss秒");
	String date = sdf.format(new Date());
	System.out.println(date);





-----------------String转Date----------------
	/*
	 *  DateFormat类方法 parse
	 */
	SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
	Date date = sdf.parse("1995-5-6");
	System.out.println(date);




-----------------Calendar类----------------
	/*
	 *   日历类 java.util.Calendar
	 *   抽象类,使用他的子类对象
	 *   
	 *   Calendar类的静态方法 getInstance() 直接返回子类对象
	 */
	Calendar c = Calendar.getInstance();
	System.out.println(c);
	

	/*
	 * int get(int field)
	 */
	// 获取年份
	int year = c.get(Calendar.YEAR);
	// 获取月份
	int month = c.get(Calendar.MONTH) + 1;
	// 获取天数
	int day = c.get(Calendar.DAY_OF_MONTH);
	System.out.println(year + "年" + month + "月" + day + "日");


	/*
	 * set(int field,int value)
	 * set(int year,int month,int day)
	 */
	// 设置到10月
	c.set(Calendar.MONTH, 9);
	// 设置到2019年5月1日
	c.set(2019, 4, 1);


	/*
	 * add(int field, int value)：进行整数的偏移 
	 */
	// 向后偏移280天
	c.add(Calendar.DAY_OF_MONTH, 280);
	

	/*
	 * getTime() ：把日历对象,转成Date日期对象
	 */
	Date date = c.getTime();
	



-----------------空集合----------------
Collections.emptyList()、emptySet()、emptyMap()

如果你想new一个空List，而这个List以后也不会再添加元素，那么就用 Collections.emptyList()。
new ArrayList() 或者 new LinkedList() 在创建的时候有会有初始大小，浪费内存

注意的地方：
这个空的集合是不能调用.add()添加元素的，会直接报异常。因为源码就是这么写的：直接抛异常。