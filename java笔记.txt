



-----------------包装类Integer----------------
String转int：
	int Interger.parseInt(String s);
	int Interger.parseInt(String s,int radix);	// 进制

int转String：
	int i=3;
	String s1=i+"";
	String s2=Integer.toString(i);	// 麻烦。用上面的 +""


-----------------System类----------------

static long currentTimeMillis() 获取当前系统时间的毫秒值（1970）【可以求差计算程序执行时间】
static void exit(int status) 结束正在运行的Java程序。参数传入一个数字即可。通常传入0记为正常状态，其他为异常状态
static void gc() 运行JVM中的垃圾回收器，完成内存中垃圾的清除。
static void arraycopy(Object src,int srcPos,Object dest,int destPos,int length) 将源数组的部分元素复制到目标数组的指定位置
	int[] src = new int[]{1,2,3,4,5};
	int[] dest = new int[]{6,7,8,9,10};
	System.arraycopy(src,0,dest,0,3); 	//dest:[1,2,3,9,10]




-----------------Arrays类----------------
此类包含用来操作数组的各种方法

sort：升序排序
	int[] arr = {1,5,9,3,7};
	Arrays.sort(arr);					// arr:{1,3,5,7,9}

toString：
	int[] arr = {1,5,9,3,7};
	String str = Arrays.toString(arr); 	// str:[1, 3, 5, 7, 9]

binarySearch：查找给定元素值出现的位置。若没有查询到，返回值为负。要求该数组必须是个有序的数组。
	int[] arr = {1,3,4,5,6};
	int index = Arrays.binarySearch(arr, 4); // 2
	int index2= Arrasy.binarySearch(arr, 7); // -6



-----------------BigInteger----------------
java中long型为最大整数类型，对于超过long型的数据如何去表示呢？，而不是直接用运算符。

	BigInteger big1 = new BigInteger("123456789098765432154210");
	BigInteger big2 = new BigInteger("98765432101234567890");
	BigInteger bigAdd = big1.add(big2);
	BigInteger bigSub = big1.subtract(big2);
	BigInteger bigMul = big1.multiply(big2);
	BigInteger bigDiv = big2.divide(big1);




-----------------BigDecimal----------------
    System.out.println(0.09 + 0.01);	//0.09999999999999999
    System.out.println(1.0 - 0.32);		//0.6799999999999999
    System.out.println(1.015 * 100);	//101.49999999999999
    System.out.println(1.301 / 100);	//0.013009999999999999

double和float类型在运算中很容易丢失精度，造成数据的不准确性，Java提供BigDecimal类可以实现浮点数据的高精度运算。

	BigDecimal big1 = new BigDecimal("0.09");
    BigDecimal big2 = new BigDecimal("0.01");
    //add
    BigDecimal bigAdd = big1.add(big2);
    
    BigDecimal big3 = new BigDecimal("1.0");
    BigDecimal big4 = new BigDecimal("0.32");
    //subtract
    BigDecimal bigSub = big3.subtract(big4);
    
    BigDecimal big5 = new BigDecimal("1.105");
    BigDecimal big6 = new BigDecimal("100");
    //multiply
    BigDecimal bigMul = big5.multiply(big6);

    divide：除法，可以指定保留位数，和保留方式




-----------------长度的3种表示----------------
	数组.length
	字符串.length()
	集合.size()



-----------------集合继承关系图----------------

                     Collection接口     
                           |
    		---------------------------------
    		|                               |
    	List接口                         Set接口
    		|                               |
     ----------------                 --------------
     |              |                 |            |
ArrayList类    LinkedList类     HashSet类    LinkedHashSet类

Collection接口中的方法，是集合中所有实现类必须拥有的方法：
	Object[] toArray() 集合转成数组
    boolean contains(Object o) 判断对象是否存在于集合中，利用equals逐个比较判断
    void clear() 清空集合中的所有元素
    boolean remove(Object o) 移除集合中指定的元素（有多个的话只移除第一个）

在使用ArrayList类时，该类已经把所有抽象方法进行了重写。





-----------------list接口-----------------
list接口的常用子类：
	1 ArrayList：是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询、遍历，所以ArrayList是最常用的集合。
	2 linkedList：是链表结构。元素增删块，查找慢。提供了大量首尾操作的方法。
		addFirst() addLast() getFirst() getLast() removeFirst() removeLast()

例子：
	List<String> list = new ArrayList<String>();

	add()
	add(int index, Object e)

	remove(Object e) 			// 返回值为被删除的元素
	remove(int index) 			// 返回值为被删除的元素

	set(int index, Object e)	// 替换

	get(int index)

遍历方法：
	1 普通for
		for(int i=0;i<list.size();i++){
			 String txt=list.get(i);
			 System.out.println(txt);
		}
	2 增强for
		for (String txt : list) {
			System.out.println(txt);
		}
	3 迭代器
		Iterator<String> it=list.iterator();
		while(it.hasNext()){
			String txt=it.next();
			System.out.println(txt);
		}

Iterator的并发修改异常：java.util.ConcurrentModificationException
	在迭代时，不要改变集合的长度。
	Iterator<String> it = list.iterator();	//包含"a" "b" "c"
	while(it.hasNext()){
		String str = it.next();
		if("b".equals(str)){
			list.add("123");	// 该操作会导致程序出错
		}
	}




-----------------set集合-----------------
不能有重复，通过元素的equals方法，来判断是否为重复元素

遍历方法：
	1 增强for
	2 迭代器
		Iterator<String> it=set.iterator();
		while(it.hasNext()){
			String txt=it.next();
			System.out.print(txt+"\t");
		}



-----------------HashSet-----------------
此类实现Set接口，采用哈希表结构存储数据（实际上是一个HashMap集合）
哈希表：链表数组结合体。存取、查询都快，线程不安全。

HashSet集合不能保证迭代顺序与元素存储顺序相同。

保证元素唯一性的方式依赖于：hashCode()与equals()方法。
Object类有hashCode方法，所以任何对象都有这个方法。
在向哈希表中存放对象时，会调用对象的hashCode方法，算出对象在表中的存放位置。如果两个对象hashCode方法算出结果一样(这种现象称为"哈希冲突")，这时会调用对象的equals方法，比较这两个对象是不是同一个对象。

给HashSet中存储JavaAPI中提供的类型元素时，不需要重写元素的hashCode和equals方法，因为这两个方法，在JavaAPI的每个类中已经重写完毕，如String类、Integer类等。

如果我们往集合中存放自定义的对象，那么保证其唯一，就必须复写hashCode和equals方法建立属于当前对象的比较方式。（myE提供自动生成hashCode和equals）

	Set<String> set =new HashSet<String>();
	set.add("aaa");
	set.add("bbb");		// 返回true
	set.add("ccc");
	set.add("ddd");
	set.add("bbb");		// 返回false
	for (String string : set) {
		System.out.print(string+'\t');
	}
	输出结果:
		aaa	ddd	ccc	bbb

	说明：String类重写了hashCode方法，是通过包含的所有字符计算出来的。所以两个"bbb"计算出来的hashCode相同。
	set发现第二个"bbb"的哈希值，和第一个"bbb"的哈希值相同，为了判断它们是不是相同元素，会调用equals方法去比较两个对象。
	因为String类重写了equals方法，比较的不是地址，而是字符，所以返回true。
	set就认为这两个"bbb"是相同的，不重复存储。


HashSet有一个子类LinkedHashSet，它是链表和哈希表组合的一个数据存储结构，保证元素的存入和取出的顺序一致。




-----------------Collections-----------------
Collections是集合工具类，用来对集合进行操作。部分方法如下：

1 sort(List)	// 对List升序
	Collections.sort(list);	//[33,11,77,55] -> [11,33,55,77]


2 shuffle(List) // 对List打乱存储顺序
	//list集合元素 [11,33,55,77]
	Collections.shuffle(list);
	//使用shuffle方法后，集合中的元素为[77,33,11,55]，每次执行该方法，集合中存储的元素位置都会随机打乱


3 emptyList()、emptySet()、emptyMap()
	如果你想new一个空List，并且以后也打算再添加元素，那么就用 Collections.emptyList()。
	new ArrayList() 或者 new LinkedList() 在创建的时候有会有初始大小，浪费内存
	注意：不能添加元素的，会直接报异常。




-----------------集合体系中的面向对象思想-----------------

接口：用来明确所有集合中该具有的功能，相当于规定功能标准；
抽象类：把多个集合中功能实现方式相同的方法，抽取到抽象类实现，具体集合中不再写，直接继承到。
具体类：继承抽象类，实现接口，重写所有抽象方法。每个具体集合类，根据自身的数据存储结构方式，对接口中的功能方法，进行不同方式的实现。




-----------------map接口-----------------
collection中的元素是"单身"的，map中的元素是"成对"的。collection和map之间没有任何继承关系。

map<K,V>接口
	---HashMap<K,V>：最常用的Map实现。只是将一个键和值相对应，并没有其他的功能。
		---LinkedHashMap<K,V>：存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复。

如果键是自定义对象，为了保证唯一性，需要重写键的hashCode()、equals()方法。

	Map<String,Integer> map = new HashMap<String,Integer>();
	
	put()
	get()

遍历方法：
	1 获取所有的key，通过key得到value【利用key的唯一性】
		Set<String> keySet=map.keySet();
		for(String key:keySet){
			Integer value=map.get(key);		
		}
	2 Entry是Map中用来保存一个键值对的，而Map实际上就是多个Entry的集合。
		Set<Entry<String,Integer>> entrySet=map.entrySet();
		for (Entry<String, Integer> entry : entrySet) {
			String key=entry.getKey();
			Integer value=entry.getValue();
		}
	如果要保证map中存放的key和取出的顺序一致，可以使用LinkedHashMap





-----------------变量--------------------【START】

变量是内存中的小容器，用来存储数据。那么计算机内存是怎么存储数据的呢？
最小信息单元叫“位（bit）”，我们又称之为“比特位”，通常用小写的字母b表示。而计算机最小的存储单元叫“字节（byte）”，通常用大写字母B表示，字节是由连续的8个位组成。
当程序需要使用存储空间时，操作系统最小会分派给程序1个字节，而不是1个位。

1B(字节) = 1byte = 8bit = 8b
1KB = 1024B
1MB = 1024KB
1GB = 1024MB
1TB = 1024GB
1PB = 1024TB



---------------基本类型：4类8种--------------

整型	
	byte	1字节	-128～127
	short	2		-32768～32767
	int		4		-2147483648～2147483648
	long	8		-2^63～2^63-1
浮点型
	float	4		-3.403E38～3.403E38
	double	8		-1.798E308～1.798E308
字符型
	char	2		表示一个字符，如('a'，'A'，'0'，'家') 0~65535
布尔型
	boolean	1		只有两个值true与false




---------------char--------------
char可以自动转成int类型，会查询编码表，得到整数
int转成char时，需要强制转换，查询编码表

打印a-z：
	char c='a';
	for(int i=0;i<26;i++){
		System.out.println(c);
		c++;
	}




---------------常量与类型--------------
100是整数常量，但它是byte、short、int、long中的哪一种呢？
是int，因为默认是int

java中默认的整数类型是int类型
在Java中，整数常量如果不在int取值范围之间，就必须添加“L”后缀（小写的也可以，但建议使用大写），不然会报错。在int取值范围之间的也可以添加“L”后缀。
所有添加了“L”后缀的整数常量都是long类型的，例如：100L、12345678901L都是long类型的常量。

java中默认的浮点类型是double类型
浮点类型的常量也可使用后缀，在Java中所有没有后缀以及使用“D”后缀（小写也可以，但建议使用大写）的小数都是double类型；float类型常量必须添加“F”后缀（小写也可以，但建议使用大写）
3.14没有后缀，所以它是double类型
5.28D为double类型
1.26F为float类型




---------------数据类型转换--------------
1 自动：
	取值范围小的数据类型 -> 范围大的数据类型
	byte -> short -> int -> long -> float -> double
	如：
		double d=100;

2 手动：强制
	范围大 -> 范围小
	如：
		int  i = (int)6.718;   //i的值为6
		或
		double  d = 3.14;
		int  i2 = (int)d;     //i2的值为3

boolean类型不能进行任何类型转换！


	byte b=100;
	b=b+1;	// 报错

	byte b=100;
	b+=1;	// 不报错，相当于b=(byte)b+1;




---------------逻辑运算符--------------

	&	与		false&true		False
	|	或		false|true		True
	^	异或	true^flase		True
	!	非		!true			Flase
	&&	短路与	false&&true		False
	||	短路或	false||true		True

短路与、或：只要能判断出结果则后边的部分就不再运行




---------------Scanner类：输入--------------
包：java.util.Scanner;

	Scanner sc = new Scanner(System.in);
	int n = sc.nextInt();
	String str = sc.next();



---------------Random类：随机数--------------
包：java.util.Random;

	Random r = new Random(); 
	// 随机整数，[0,100)
	int i = r.nextInt(100); 
	// 随机小数，[0.0,1.0)
	double d = r.nextDouble(); 



---------------switch语句--------------
switch (表达式){
	case 目标值1:
		执行语句1
		break;
	．．．．．．
	default:
		执行语句n+1
		break;
}
表达式只能是：byte、short、char、int类型的值
jdk5.0+：枚举
jdk7.0+：String



--------------------------------
数据类型：
	1）基本数据类型：8种
	2）引用数据类型: 数组、类、接口、枚举
		ArrayList是集合，集合是特殊的类。

包装类：
	int --> Integer
	byte --> Byte
	short --> Short
	long --> Long
	char --> Character
	double --> Double
	float --> Float
	boolean --> Boolean
包装类是对象，可以是null，可以有属性和方法。泛型只能是引用类型



---------------数组-----------------
定义：
	int[] arr = new int[100];	// arr中每个元素都是默认值
	int[] arr=new int[]{1,2,3,4};
	int[] arr={1,2,3,4};

1 引用类型，arr中存的是数组第一个元素的首地址
2 长度固定 arr.length
  只能存一个类型
3 默认值（初始值）：

		数据类型			|		默认初始化值
	byte、short、int、long	|	0
	float、double			|	0.0
	char					|	一个空格，即’\u0000’
	boolean					|	false
	引用数据类型			|	null
4 异常：
	1 索引越界异常 
		arr[-3]
		arr[201]
	2 空指针异常 
		arr=null;
		arr[2]

5 二维数组
	定义：
		int[][] arr = new int[3][4];
		int[][] arr = {{1,2},{3,4,5,6},{7,8,9}};



---------------方法重载-----------------
根据参数不同，来区分。和返回值无关
System.out.println()就是重载




--------------------------------

	public static void main(String[] args){
		int arr[]={1,2,3};
		change(arr);
		System.out.println(arr[0]);	// 100
	}

	static void change(int[] arr){
		arr[0]=100;
	}

引用类型传参，传的是地址



--------------------------------

	Phone phone=new Phone();
内存中发生了什么？
	JVM在堆内存中开辟了一块空间，存储新new的对象
	属性也跟着进入堆内存，赋予默认值。
	JVM把这块内存的地址，传递给p。p中保存的是新对象在内存中的地址。




---------------ArrayList----------------
为了保存数目不确定的元素，JDK中提供了一系列特殊的类，这些类可以存储任意类型的元素，并且长度可变，统称为集合。
ArrayList集合是程序中最常见的一种集合，它属于引用数据类型中的类。

	ArrayList<String> arr1=new ArrayList<String>();
	ArrayList<Integer> arr2=new ArrayList<Integer>();

包：java.util.ArrayList
只能存储引用类型，不能存基本类型，要用包装类。
存：add()
取：get()
长度：size()
不常用方法：
	boolean add（int index,  Object obj）	将指定元素obj插入到集合中指定的位置
	Object remve（int index）	从集合中删除指定index处的元素，返回该元素
	void clear()	清空集合中所有元素
	Object set（int index, Object obj）	用指定元素obj替代集合中指定位置上的元素




--------------------------------

java不允许多继承，因为有安全问题。用多实现。


子类、父类中，出现重名的field、方法时，默认用子类的，想要用父类需要指明super.xxx




--------------抽象类 抽象方法----------------

	abstract class Worker {
		public abstract void work();
	}

1、抽象类和抽象方法都需要被abstract修饰。抽象方法一定要定义在抽象类中。
2、抽象类不可以new
3、只有覆盖了抽象类中所有的抽象方法后，其子类才可以创建对象。否则该子类还是一个抽象类。

4、abstract不可以和哪些关键字共存？	
1、private
2、final
3、static




--------------接口----------------
	public interface Animal{
		public abstract void eat();
	}

1 是比抽象类更为抽象的”类”。不能new
2 将功能的"定义"与"实现"分离

3 接口中的方法：
	只能是public abstract的，可以省略不写
	接口中：void eat();		// 等价于public abstract void eat();
	
4 接口中的成员变量：
	只能是public static final的，可以省略不写，
  	接口中：int a=1; 		// 等价于public static final int a=1;
  	可以直接：接口.a

5 实现类，必须重写接口中的【所有】抽象方法
  如果没有重写所有，那么实现类还是一个抽象类

6 为什么要定义接口，和抽象类相比有什么优势？
	解决多继承的弊端。将多继承通过多实现完成了。

7 父类中定义的事物的基本功能。接口中定义的事物的扩展功能。
	class 缉毒犬 extends 犬科 implements 缉毒

8 多个接口之间可以使用extends进行继承。
	interface Fu1{
		void show1();
	}
	interface Fu2{
		void show2();
	}
	interface Zi extends Fu1,Fu2{
		void show3();
	}

接口没有构造方法

抽象类&接口的选用:
优先选用接口,尽量少用抽象类;
需要为子类提供共性功能时才选用抽象类;




--------------------------------
java三大特征：继承 + 封装 + 多态

多态：
	体现：Animal a = new Cat();
	好处：提高了程序的扩展性。
	弊端：不可以访问子类中特有的方法。



----------------多态----------------
1 field：当子父类中出现同名的成员变量时，多态调用该变量时
	class Fu {
		int num = 4;
	}
	class Zi extends Fu {
		int num = 5;
	}
	public class Demo {
		public static void main(String[] args) 	{
			Fu f = new Zi();
			System.out.println(f.num);	// 4
			Zi z = new Zi();
			System.out.println(z.num);	// 5
		}
	}

2 method：当子父类中出现同名的成员方法时，多态调用该方法时：
		编译看左边，运行看右边。
	
	class Fu {
		int num = 4;
		void show()	{
			System.out.println("Fu show num");
		}
	}
	class Zi extends Fu {
		int num = 5;
		void show()	{
			System.out.println("Zi show num");
		}
	}
	class Demo {
		public static void main(String[] args) 	{
			Fu f = new Zi();
			f.show();	// Zi show num
		}
	}




----------------instanceof----------------

	Person p1 = new Student();
	boolean flag1 = p1 instanceof Student; 	// true
	boolean flag2 = p1 instanceof Teacher; 	// false
	boolean flag3 = p1 instanceof Person; 	// true




----------------多态 转型----------------
向上转型：
	Person p = new Student();
向下转型：
	Student stu = (Student) p;

什么时候使用upcasting：使用父类的功能就能完成相应的操作，如：
		Animal a = new Dog();
	    a.eat();

什么时候使用downcasting：
	当要使用子类特有功能时，如：
		Dog d = (Dog) a;
		d.lookHome();
	弊端：容易发生ClassCastException类型转换异常。在转换之前必须做类型判断，如：
		if( !a instanceof Dog)




----------------构造方法----------------
1 默认构造方法
	如果没有写构造方法，在编译时，编译器会自动添加默认的空构造方法

2 一个类中可以有多个构造方法，多个构造方法是以重载的形式存在的
  构造方法之间的调用，可以通过this关键字来完成。
  调用其他构造方法的语句必须定义在构造方法的第一行。

3 构造方法是可以被private修饰的，作用：其他程序无法创建该类的对象




----------------this super---------------
1 this：
	一个构造方法调用另一个构造方法
	this.field

2 super：
	在创建子类对象时，父类的构造方法会先执行，因为子类中所有构造方法的第一行有默认的隐式super();语句。
	当父类中没有空参数构造方法时，子类的构造方法必须有显示的super语句。
	
	如果子类的构造方法第一行写了this调用了子类的其他构造方法，那么super调用父类的语句还有吗？————没有了。

	父类构造方法中是否有隐式的super呢？
	也是有的。记住：只要是构造方法默认第一行都是super();
	父类的父类是谁呢？super调用的到底是谁的构造方法呢？————Object类




----------------继承中的构造方法---------------

1 如果我们没写任何的构造方法，编译器提供给我们一个空参数构造方法
  如果我们手动给出了构造方法，编译器不会再给我们提供默认的空参数构造方法

2 在构造方法中，默认的第一条语句为 super();
  它是用来访问父类中的空参数构造方法，进行父类成员的初始化操作

3 当父类中没有空参数构造方法的时候，怎么办？
	a: 通过 super(参数) 访问父类有参数的构造方法
	b: 通过 this(参数) 访问本类中其他构造方法，其他构造方法需要调用了有参super

4 super(参数) 与 this(参数) 不能同时在构造方法中存在






----------------final---------------
final是个修饰符，它可以用来修饰：
	类
	类的成员：field method
	局部变量

1 final修饰的类不可以被继承。但是可以继承其他类。

2 final修饰的方法不可以被覆盖。但父类中没有被final修饰方法，子类覆盖后可以加final。

3 final修饰的变量称为常量，这些变量只能赋值一次。在编译生成.class文件后，该变量变为常量值
	final int i = 20;
	i = 30; 			// 报错

  引用类型的变量值为地址，地址值不能更改，但是地址内的对象属性值可以修改。
	final Person p = new Person();
	Person p2 = new Person();
	p = p2; 			// 报错
	p.name = "小明";	// ok

4 final修饰的成员变量，需要在创建对象前赋值，否则报错。
	class Demo {
		//直接赋值
		final int m = 100;
		
		//final修饰的成员变量，需要在创建对象前赋值，否则报错。
		final int n; 
		public Demo(){
			//可以在创建对象时所调用的构造方法中，为变量n赋值
			n = 2016;
		}
	}





----------------static---------------
特点：
	被所有的对象所共享
	可以通过类名直接调用

注意事项：
	static的成员，随着类的加载而加载，优先于对象存在
	在static方法中，不能使用this super
	在static方法中，只能调用static的变量、方法


使用public static final来定义静态常量。此时变量名用全部大写，多个单词使用下划线连接。

	class Company {
		public static final String COMPANY_NAME = "SLA";
	}

	System.out.println(Company.COMPANY_NAME); //打印传智播客
	

注意：
	接口中的每个成员变量都默认使用public static final修饰。由于接口没有构造方法，所以必须显示赋值。
	interface Inter {
		public static final int COUNT = 100;
	}

	Inter.COUNT




----------------内部类---------------

1 内部类：在一个类中，定义了一个新类，这个新的类就是内部类
  内部类分为成员内部类与局部内部类

2 成员内部类

	class Body {
		private boolean life= true;
	    public class Heart {
			public void jump() {
				System.out.println("生命状态" + life);
			}
		}
		public static void main(String[] args) {
			Body.Heart bh = new Body().new Heart();
			bh.jump();
		}
	}

3 局部内部类
	class Party {
		public void puffBall(){
			class Ball {
	            public void puff(){System.out.println("气球膨胀了");}
			}	
			new Ball().puff();
		}
		public static void main(String[] args) {
			Party p = new Party();
			p.puffBall();
		}
	}

4 内部类的实际使用：匿名内部类
	内部类是为了应对更为复杂的类间关系。查看源代码中会涉及到，而在日常业务中很难遇到
	最常用到的内部类就是匿名内部类，它是局部内部类的一种。

		public abstract class Person{
			public abstract void eat();
		}
		Person  p = new Person(){
			public void eat() {
				System.out.println("eat.....");
			}
		};
		p.eat();

	详见：https://www.cnblogs.com/nerxious/archive/2013/01/25/2876489.html




----------------权限修饰符---------------

					public	protected	默认的	private
在当前类中			Y		Y			Y		Y
同一包中的其他类	Y		Y			Y
不同包中的子类		Y		Y	
不同包中的其他类	Y

归纳一下：
	要想仅能在本类中访问：private
	要想本包中的类都可以访问不加修饰符即可；
	要想本包中的类与其他包中的子类可以访问：protected
	要想所有包中的所有类都可以访问：public

易错：
	不写修饰符的，在其他包中的子类里不能用

注意：如果类用public修饰，则类名必须与文件名相同。一个文件中只能有一个public修饰的类。




----------------protected---------------
protected：
	1 同一包中的类可以用
	2 其他包中的子类可以用，但是只能在子类的里面调用！！

		public class A{
			protected void func(){}
		}
		
		// 另一个包中：
		public class B extends A{
			void func2(){
				func();				// ok
				new A().func();		// 报错
			}
			public static void main(String[] args){
				new B().func();		// ok
				new A().func();		// 报错
			}
		}


--------------------------------
集合和数组的区别：

	1： 数组：长度固定
		集合：长度可变

	2： 数组：基本、引用都能存
		集合：只能存引用

	3： 数组存储的元素必须是同一个数据类型；
		集合存储的对象可以是不同数据类型。



-----------------jdk-----------------
jdk版本：1.1   1.2   1.3   1.4   5.0（变化很大，所以不叫1.5，叫5.0）
jdk5.0新特性：
	泛型
	枚举
	静态导入
	自动拆装箱
	增强for
	可变参数



-----------------jdk5.0新特性：泛型-----------------
泛型里面不能写基本数据类型，要写对应的包装类（因为集合中只能存引用，不能存基本）
	byte		Byte
	short		Short
	int 		Integer
	long 		Long
	folat 		Float
	double 		Double
	char 		Character
	boolean 	Boolean

1 泛型一般使用在集合上，常用集合：list set map
	为什么要使用泛型？
		新元素放入集合后，失去本身的类型，变成Object类型。
		想取出的时候要进行类型转换，很容易出错。
	
2 在类中使用泛型（知道即可）
	例如：API中的ArrayList
	class ArrayList<E>{ 
		public boolean add(E e){...}
    	public E get(int index){...}
	}

	ArrayList<String> list = new ArrayList<String>();

3 在方法中使用泛型（知道即可）
	例如，API中的ArrayList集合中的方法：
	public <T> T[] toArray(T[] a){...}

	ArrayList<String> list = new ArrayList<String>();
	Integer[] arr = new Integer[100];
	Integer[] result = list.toArray(arr);

4 泛型擦除
	泛型只存在于源代码中，编译后就不存在了

5 泛型的通配符 ?

5 泛型的限定
   /*
    *  酒店员工:厨师、服务员、经理,分别存储到3个集合中
    *  定义方法,可以同时遍历3集合,遍历三个集合的同时,可以调用work()
    */
	import java.util.ArrayList;
	import java.util.Iterator;
	public class GenericTest {
		public static void main(String[] args) {

			//创建3个集合对象
			ArrayList<ChuShi> cs = new ArrayList<ChuShi>();
			ArrayList<FuWuYuan> fwy = new ArrayList<FuWuYuan>();
			ArrayList<JingLi> jl = new ArrayList<JingLi>();

			//每个集合存储自己的元素，略

			myIterator(jl);
			myIterator(fwy);
			myIterator(cs);

		}
	    /*
	     * 如果用?,it.next()方法取出来的是Object类型,不能调用work()。可以强转:(Employee)it.next()。但不安全
	     * 方法参数: 控制,只能传递Employee对象或Employee子类的对象
	     * 泛型的限定：
	     *   ? extends Employee 可以传递Employee和子类对象
	     *   ? super   Employee 可以传递Employee和父类对象
	     */
		public static void myIterator(ArrayList<? extends Employee> array){
			Iterator<? extends Employee> it = array.iterator();
			while(it.hasNext()){
				//it.next()的数据类型：Employee
				Employee e = it.next();
				e.work();
			}
		}
	}




-----------------jdk5.0新特性：枚举-----------------
需要在一定的范围内取值（红绿灯）

枚举是一种特殊的类。
枚举类中声明的每一个枚举值，都是枚举类的一个实例对象。
与java中的普通类一样，在声明枚举类时，也可以声明属性、方法和构造函数，但构造函数必须是private的。
枚举类可以实现接口、继承抽象类。
jdk5中扩展了switch语句，它除了可以接受 byte short char int之外，还可以接收枚举类型。

	http://blog.csdn.net/qq_27093465/article/details/52180865

常用方法：
	color.name()：返回枚举的名称
	color.ordinal()：返回枚举的下标（从0开始）

还有两个方法不在API里面，但是编译的时候会生成：
	Color.valueof(String name)：返回枚举对象
	Color.values()：返回所有枚举对象数组




-----------------jdk5.0新特性：静态导入-----------------
了解即可，不常用。容易出错

可以在代码里面，直接导入静态方法或常量

	import static java.lang.System.out;
	import static java.lang.Math.abs;

	public class staticImport {
		public static void main(String[] args) {
			double num=abs(-2.9);
			out.println(num);			
		}
	}




-----------------jdk5.0新特性：自动拆装箱-----------------
基本类型 <----> 包装类 自动转换

	Integer i=10;	// 自动装箱
	int j=i;		// 自动拆箱

jdk1.4-中不能自动转换，上面的写法会报错，需要：
	Integer i=new Integer(10);
	int j=i.intValue();
jdk是向下兼容的，所以在jdk1.5+中上面两行可以运行	

	public static void main(String[] args) {
		doo(1);		
	}
	private static void doo(double d){
		System.out.println("double");
	}

	private static void doo(Integer i){
		System.out.println("Integer");
	}
	输出结果：double
	分析：jdk1.4-中肯定是double。jdk1.5+虽然有自动拆装箱，但是为了保证向下兼容，所以还是double




-----------------jdk5.0新特性：增强for循环-----------------
为什么要引入增强for？
	为了替代Iterator。如果实现了Iterator接口，就可以使用增强for循环。增强for的底层实现就是使用Iterator

谁能使用增强for？
	数组；实现了Iterator接口的集合

在集合中使用增强for遍历：
	list set实现了Iterator接口，所以可以使用增强for
	map没有实现Iterator接口，不可以使用增强for




-----------------jdk5.0新特性：可变参数-----------------
本质就是一个数组

	public static void main(String[] args) {
		add(1,2);
		add(2,3,4);		
	}
	public static void add(int...nums){
		int sum=0;
		for (int i : nums) {
			sum+=i;
		}
		return sum;
	}

可变参数必须放在最后；只能有一个可变参数




-----------------反射（理解就行）-----------------
应用在一些通用性比较高的代码中
后面学到的框架，大多数都是使用反射来实现的

在框架开发中，都是基于配置文件开发
	在配置文件中配置了类，可以通过反射得到类中的所有内容

类中的所有内容：属性、构造方法、普通方法

反射的原理：
	首先需要把java文件保存到本地硬盘 .java
	编译：.java -> .class文件
	使用jvm，把class文件通过类加载到内存中。class文件在内存中使用Class类表示

	当使用反射的时候，首先需要获取到Class类。得到了这个类之后，就可以操作class文件里面的所有内容：属性、构造方法、普通方法(private的也可以)

获取Class类的最常用方法：
	Class c3=Class.forName("emily.Person");	// 获取Class对象
	Person p1=(Person)c1.newInstance();	// 利用Class对象创建实例类



-----------------java画图-----------------		
生成验证码：
	
	// 得到图片缓冲区
	BufferedImage bi=new BufferedImage(70, 30, BufferedImage.TYPE_INT_RGB);
	
	// 得到它的绘制环境
	Graphics2D g2=(Graphics2D) bi.getGraphics();
	
	// 设置颜色
	g2.setColor(Color.PINK);		
	// 画一个矩形，填充整张图片（相当于设置了背景色）
	g2.fillRect(0, 0, 70, 30);
	

	// 设置颜色
	g2.setColor(Color.BLACK);	
	// 设置字体
	g2.setFont(new Font("微软雅黑",Font.ITALIC,16));
	// 写字
	g2.drawString("hello", 15,20);
	
	// 保存图片
	try {
		ImageIO.write(bi, "JPEG", new FileOutputStream("E:/hello.jpg"));
	} catch (FileNotFoundException e) {
		e.printStackTrace();
	} catch (IOException e) {
		e.printStackTrace();
	}




-----------------Object类-----------------
Object类是Java语言中的根类，即所有类的父类。

1 Object中的equals方法：	
	// 比较的是地址
	public boolean equals(Object obj) {
        return (this == obj);
    }

  子类重写equals方法：

  	public class Person {
  		
  		private int id = 0;
  		
  		@Override
  		public boolean equals(Object obj) {
  			if (obj instanceof Person) {
  				Person p=(Person) obj;
  				return this.id==p.id;	// 问题：为什么能取private的p.id？？
  			}else{
  				return false;
  			}
  		}
  		
  	}

2 Object中的toString方法：返回对象的类型+@+内存地址值
	
  在输出语句中，如果写的是对象，那么会默认调用对象的toString方法:
	System.out.println(p);	// 等价于下面一行
	System.out.println(p.toString());

  子类重写toString方法：
  	public class Person {
  		
  		private String name;
  		
  		Person(String name){
  			this.name=name;
  		}

  		@Override
  		public String toString() {
  			return "这个人的名字是"+this.name;
  		}
  		
  		public static void main(String[] args) {
  			Person person=new Person("小红");
  			System.out.println(person);	// 不需要写person.toString()
  		}
  	}





-----------------String类-----------------
Java 程序中的所有字符串字面值（如 "abc" ）都是String类的对象
	String str="abc";	// "abc"是String类的对象。str是引用，存的是地址

为什么输出str没有显示地址？
	————因为String类重写了toString方法

字符串的值在创建之后不能更改。就是说一旦这个字符串确定了，那么在内存区域中就生成了这个字符串，字符串本身不能改变。
"abc"这个对象不能改变，但是变量str中的地址是可以改变的。
	String str="abc";
	str="def";	// "abc"对象不变。新建了一个String类对象"def"，把它的地址给str

通过使用双引号的方式创建对象与new的方式创建对象，有什么不同呢？
	String s3 = "abc";
	String s4 = new String("abc");
	System.out.println(s3==s4); //false
	System.out.println(s3.equals(s4)); //true,因为String重写了equals方法

	s3创建，在内存中只有一个对象"abc"。这个对象在字符串常量池中
	s4创建，在内存中有两个对象。一个new的对象在堆中，一个字符串本身对象"abc"在字符串常量池中

length()

substring(int beginindex)
substring(int beginindex,int endIndex) 包括起，不包括尾。返回新字符串

boolean startsWith(String prefix);
boolean endsWith(String suffix);
boolean contains(String s);
int indexOf(String str);	// 查找第一次出现的索引，没有就-1
int indexOf(String str,int fromIndex);

char[] toCharArray();	// 转成字符数组

booleans equals(Object anObject);
booleans equalsIgnoreCase(String anotherString);

String replace(char old,char new);
String replace(String old,String new);
String trim() 去除字符串两端空格，中间的不会去除，返回一个新字符串
String toLowerCase();
String toUpperCase();




-----------------StringBuilder-----------------
String浪费内存，所以StringBuffer

StringBuilder类，也是字符串缓冲区，它和StringBuffer有什么不同呢？
	————此类提供一个与 StringBuffer 兼容的 API，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。

StringBuffer append(String str)
StringBuffer insert(int offset,String str)
StringBuffer deleteCharAt(int index)
StringBuffer delete(int start,int end)
StringBuffer replace(int start,int end,String str)
StringBuffer reverse()
String substring(int start) 
String substring(int start,int end) 




-----------------正则-----------------
String类中正则相关的方法：
	boolean matches(String regex);
	String[] split(String regex);
	String replaceAll(String regex,String replacement);


	String s = "Hello12345World6789012";
	String regex = "\\d";
	String result = s.replaceAll(regex, "*");	// Hello*****World*******




-----------------Date-----------------
时间和日期类：java.util.Date  

毫秒的0点: 
   System.currentTimeMillis() 返回long
   获取当前日期的毫秒值
   时间原点：1970年1月1日 0:00:00 英国格林威治 毫秒值是0
	long time = System.currentTimeMillis();
	System.out.println(time);

重要: 时间和日期的计算,必须依赖毫秒值
	XXX-XXX-XX = 毫秒


	Date date = new Date();		// 当前操作系统中的时间和日期

	/*
	 * Date类的long参数的构造方法
	 * 传递毫秒值,将毫秒值转成对应的日期对象
	 */
	Date date = new Date(0); 	
	System.out.println(date);	// Thu Jan 01 08:00:00 CST 1970

	/*
	 * Date类方法 setTime(long)传递毫秒值
	 */
	Date date = new Date();
	date.setTime(0);

	
	/*
	 *   Date类方法 getTime() 返回值long 毫秒值
	 */
	Date date = new Date();
	long time = date.getTime();




-----------------Date转String-----------------
格式化输出Date:

	对日期格式化的类 java.text.DateFormat 抽象类, 普通方法+抽象方法
	实际使用是子类 java.text.SimpleDateFormat 可以使用父类普通方法,重写了抽象方法

	/*
	 * 如何对日期格式化
	 *  步骤:
	 *    1. 创建SimpleDateFormat对象
	 *       在类构造方法中,写入字符串的日期格式 (自己定义)
	 *    2. SimpleDateFormat调用方法format对日期进行格式化
	 *         String format(Date date) 传递日期对象,返回字符串
	 *    日期模式:
	 *       yyyy    年份
	 *       MM      月份
	 *       dd      月中的天数
	 *       HH      0-23小时
	 *       mm      分钟
	 *       ss      秒
	 */
	SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 HH点mm分钟ss秒");
	String date = sdf.format(new Date());
	System.out.println(date);





-----------------String转Date----------------
	/*
	 *  DateFormat类方法 parse
	 */
	SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
	Date date = sdf.parse("1995-5-6");
	System.out.println(date);




-----------------Calendar类----------------
	/*
	 *   日历类 java.util.Calendar
	 *   抽象类,使用他的子类对象
	 *   
	 *   Calendar类的静态方法 getInstance() 直接返回子类对象
	 */
	Calendar c = Calendar.getInstance();
	System.out.println(c);
	

	/*
	 * int get(int field)
	 */
	// 获取年份
	int year = c.get(Calendar.YEAR);
	// 获取月份
	int month = c.get(Calendar.MONTH) + 1;
	// 获取天数
	int day = c.get(Calendar.DAY_OF_MONTH);
	System.out.println(year + "年" + month + "月" + day + "日");


	/*
	 * set(int field,int value)
	 * set(int year,int month,int day)
	 */
	// 设置到10月
	c.set(Calendar.MONTH, 9);
	// 设置到2019年5月1日
	c.set(2019, 4, 1);


	/*
	 * add(int field, int value)：进行整数的偏移 
	 */
	// 向后偏移280天
	c.add(Calendar.DAY_OF_MONTH, 280);
	

	/*
	 * getTime() ：把日历对象,转成Date日期对象
	 */
	Date date = c.getTime();
	




